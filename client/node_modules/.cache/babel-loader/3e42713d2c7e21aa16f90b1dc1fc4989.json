{"ast":null,"code":"'use strict';\n\nconst Fragment = require('./fragment');\n\nconst util = require('./util');\n\nconst ops = require('./ops');\n\nmodule.exports = class Cell extends Fragment {\n  constructor(doc, parent, opts) {\n    super(doc, parent);\n    this._pending = [];\n    this._firstPage = true;\n    this._firstRendered = false;\n    this._drawBorders = true; // create new cursor for cell context\n    // const previousCursor = this._cursor\n\n    this._cursor = this._cursor.clone();\n    applyOpts.call(this, opts);\n    this._previousStartX = this._cursor.startX;\n\n    if (this.x) {\n      this._cursor.startX = this.x;\n    } // adjust cursor according to cell padding\n\n\n    this._cursor.startX += this.paddingLeft;\n    this._cursor.width -= this.paddingLeft + this.paddingRight;\n    this._cursor.bottomOffset = this.paddingBottom - this.borderBottomWidth;\n    this._startRendering = null;\n  } /// private API\n\n\n  async _pageBreak(level, insideBreak) {\n    const renderHeight = this._startY - this._cursor.bottom;\n    const actualHeight = this._startY - this._cursor.y;\n    let contents, offset;\n\n    if (!insideBreak && this._firstPage && renderHeight / this._doc.height <= .15) {\n      // move already rendered cell content to the next page if the current cell height does only\n      // make up about 10% of the total page height\n      const idx = this._doc._contents.indexOf(this._bgLayerRef);\n\n      const take = this._endLayerRef ? this._doc._contents.indexOf(this._endLayerRef) - idx + 1 : this._doc._contents.length - idx;\n      contents = this._doc._contents.splice(idx, take);\n      offset = actualHeight - this.paddingTop + this.borderTopWidth;\n    } else {\n      // on page breaks, always draw background until the current bottom\n      this._cursor.y = this._cursor.bottom - this.paddingBottom; // create background on each page break\n\n      await this._createBackground(!this._firstRendered, false);\n      this._firstRendered = true;\n    }\n\n    this._firstPage = false;\n\n    if (this._parent) {\n      await this._parent._pageBreak(level + 1, contents === undefined);\n    } // By pushing the following at the beginning of the cell's pending queue instead of executing\n    // it directly, we ensure that is executed just before the cell's content continues rendering\n    // on the next page - especially when cells are appended horizontally into rows.\n\n\n    this._pending.unshift(async () => {\n      // reset some cursor values\n      this._cursor.x = this._cursor.startX;\n      this._cursor.cursorOffset = 0;\n\n      if (contents) {\n        await this._doc._startContentObject();\n        await this._doc._write(ops.q() + ops.cm(1, 0, 0, 1, 0, this._cursor.y - this._startY));\n\n        this._doc._contents.push.apply(this._doc._contents, contents);\n\n        await this._doc._startContentObject();\n        await this._doc._write(ops.Q());\n        this._bgLayerRef = null;\n      }\n\n      this._startY = this._cursor.y;\n\n      if (offset > 0) {\n        this._cursor.y -= offset;\n      } // apply padding after page break (but only to most inner cell)\n\n\n      if (level === 1) {\n        this._cursor.y -= this.paddingTop - this.borderTopWidth;\n        this._cursor.bottomOffset = this.paddingBottom - this.borderBottomWidth;\n      } // TODO: is there a better way of achieving this?\n\n\n      if (this._pending.length === 0) {\n        this._cursor.y = this._startY;\n      }\n    });\n  }\n\n  async _createBackground(hasTopBorder, hasBottomBorder) {\n    // if there is no backgroundColor, it is not necessary to create the background layer\n    const hasBorder = this._drawBorders && (this.borderTopWidth > 0 || this.borderRightWidth > 0 || this.borderBottomWidth > 0 || this.borderLeftWidth > 0);\n\n    if (!this.backgroundColor && !hasBorder) {\n      return;\n    } // start a new content object for the background and border layer\n\n\n    await this._doc._startContentObject(null, true); // put the background layer behind the cell\n\n    const layer = this._doc._contents.pop();\n\n    const bgLayerIndex = this._bgLayerRef ? this._doc._contents.indexOf(this._bgLayerRef) : 0;\n\n    this._doc._contents.splice(bgLayerIndex, 0, layer); // calculate background height\n\n\n    let height = this._startY - this._cursor.y;\n    const bottom = this._cursor.bottom - this.paddingBottom + this.borderBottomWidth;\n\n    if (this._startY - height < bottom) {\n      // if background height goes beyond bottom of document, trim it to the bottom\n      height = this._startY - bottom;\n    }\n\n    let chunk = ops.q(); // save graphics state\n\n    if (this.backgroundColor) {\n      // write background\n      chunk += ops.sc(this.backgroundColor[0], this.backgroundColor[1], this.backgroundColor[2]) // non-stroking color\n      + ops.re(this._cursor.startX - this.paddingLeft, this._startY - height, this.outerWidth, height) // rectangle\n      + ops.f(); // fill path\n    }\n\n    if (this._drawBorders) {\n      let borderColor = null;\n      let borderWidth = null; // draw left border\n\n      if (this.borderLeftWidth > 0) {\n        if (!borderColor || !util.rgbEqual(borderColor, this.borderLeftColor)) {\n          chunk += ops.SC(this.borderLeftColor[0], this.borderLeftColor[1], this.borderLeftColor[2]); // stroking color\n\n          borderColor = this.borderLeftColor;\n        }\n\n        if (borderWidth !== this.borderLeftWidth) {\n          chunk += ops.w(this.borderLeftWidth); // line width\n\n          borderWidth = this.borderLeftWidth;\n        }\n\n        const x = this._cursor.startX - this.paddingLeft + this.borderLeftWidth / 2;\n        const y1 = this._startY;\n        const y2 = this._startY - height;\n        chunk += ops.S(x, y1, 'm', x, y2, 'l'); // fill path\n      } // draw right border\n\n\n      if (this.borderRightWidth > 0) {\n        if (!borderColor || !util.rgbEqual(borderColor, this.borderRightColor)) {\n          chunk += ops.SC(this.borderRightColor[0], this.borderRightColor[1], this.borderRightColor[2]); // stroking color\n\n          borderColor = this.borderRightColor;\n        }\n\n        if (borderWidth !== this.borderRightWidth) {\n          chunk += ops.w(this.borderRightWidth); // line width\n\n          borderWidth = this.borderRightWidth;\n        }\n\n        const x = this._cursor.startX - this.paddingLeft + this.outerWidth - this.borderRightWidth / 2;\n        const y1 = this._startY;\n        const y2 = this._startY - height;\n        chunk += ops.S(x, y1, 'm', x, y2, 'l'); // fill path\n      } // draw top border\n\n\n      if (hasTopBorder && this.borderTopWidth > 0) {\n        if (!borderColor || !util.rgbEqual(borderColor, this.borderTopColor)) {\n          chunk += ops.SC(this.borderTopColor[0], this.borderTopColor[1], this.borderTopColor[2]); // stroking color\n\n          borderColor = this.borderTopColor;\n        }\n\n        if (borderWidth !== this.borderTopWidth) {\n          chunk += ops.w(this.borderTopWidth); // line width\n\n          borderWidth = this.borderTopWidth;\n        }\n\n        const x1 = this._cursor.startX - this.paddingLeft;\n        const x2 = x1 + this.outerWidth;\n        const y = this._startY - this.borderTopWidth / 2;\n        chunk += ops.S(x1, y, 'm', x2, y, 'l'); // fill path\n      } // draw bottom border\n\n\n      if (hasBottomBorder && this.borderBottomWidth > 0) {\n        if (!borderColor || !util.rgbEqual(borderColor, this.borderBottomColor)) {\n          chunk += ops.SC(this.borderBottomColor[0], this.borderBottomColor[1], this.borderBottomColor[2]); // stroking color\n\n          borderColor = this.borderBottomColor;\n        }\n\n        if (borderWidth !== this.borderBottomWidth) {\n          chunk += ops.w(this.borderBottomWidth); // line width\n\n          borderWidth = this.borderBottomWidth;\n        }\n\n        const x1 = this._cursor.startX - this.paddingLeft;\n        const x2 = x1 + this.outerWidth;\n        const y = this._startY - height + this.borderBottomWidth / 2;\n        chunk += ops.S(x1, y, 'm', x2, y, 'l'); // fill path\n      }\n    }\n\n    if (chunk.length > 0) {\n      chunk += ops.Q(); // restore graphics state\n\n      await this._doc._write(chunk);\n    } // for succeeding pages put background layers at index 0 (for bgLayerRef === null, index 0\n    // will be used)\n\n\n    this._bgLayerRef = null; // update startAt to take page break into account\n\n    this._startY = this._cursor.startY;\n  }\n\n  async _start() {\n    if (!this._doc._currentContent) {\n      await this._doc._startPage();\n    }\n\n    if (this.minHeight > 0 && !this._parent._cursor.doesFit(this.minHeight)) {\n      await this._parent._pageBreak(1);\n    }\n\n    if (this.y !== undefined) {\n      this._cursor.y = this.y;\n    } // Note: We could call `doesFit(this.minHeight)` here again to test whether the cell fits on the\n    // newly created page. However, instead of throwing an error, when the minHeight is greater than\n    // the document height, the minHeight is bounded to the documents height.\n\n\n    this._startY = this._cursor.y;\n    this._cursor.x = this._cursor.startX;\n    this._cursor.y -= this.paddingTop;\n    this.outerWidth = this._cursor.width + this.paddingLeft + this.paddingRight; // start a new content layer for cells\n    // save the current layer ref, this will be used to place the background and border layer\n    // after the cell has been rendered\n    // Note: saving the index directly would  not work for nested rendering tasks\n\n    this._bgLayerRef = await this._doc._startContentObject(null, true); // block execution until the row knows about all its cells, otherwise it is possible that the\n    // rendering scheduler (_pending) removes this._pending before the cell's end got called\n\n    if (!this._ended) {\n      await new Promise(resolve => {\n        this._startRendering = resolve;\n      });\n    }\n  }\n\n  async _end() {\n    // apply bottom padding\n    this._cursor.y -= this.paddingBottom;\n    const height = this._startY - this._cursor.y;\n\n    if (height < this.opts.minHeight) {\n      this._cursor.y -= this.opts.minHeight - height;\n    } // create final createBackground\n\n\n    await this._createBackground(!this._firstRendered, true); // restore cursor\n\n    this._cursor.x = this._previousStartX;\n  }\n\n  end() {\n    if (this._startRendering) {\n      this._startRendering();\n    }\n\n    return Fragment.prototype.end.call(this);\n  }\n\n};\n\nfunction applyOpts(opts) {\n  this.opts = opts;\n\n  if ('width' in opts) {\n    this._cursor.width = opts.width;\n  }\n\n  if ('x' in opts) {\n    this.x = opts.x;\n  }\n\n  if ('y' in opts) {\n    this.y = opts.y;\n  }\n\n  this.paddingTop = opts.paddingTop || opts.padding || 0;\n  this.paddingRight = opts.paddingRight || opts.padding || 0;\n  this.paddingBottom = opts.paddingBottom || opts.padding || 0;\n  this.paddingLeft = opts.paddingLeft || opts.padding || 0; // background creation callback\n\n  this.backgroundColor = util.colorToRgb(opts.backgroundColor);\n  this.borderTopWidth = opts.borderTopWidth || opts.borderWidth || 0;\n  this.borderTopColor = util.colorToRgb(opts.borderTopColor || opts.borderColor || 0x000000);\n  this.borderRightWidth = opts.borderRightWidth || opts.borderWidth || 0;\n  this.borderRightColor = util.colorToRgb(opts.borderRightColor || opts.borderColor || 0x000000);\n  this.borderBottomWidth = opts.borderBottomWidth || opts.borderWidth || 0;\n  this.borderBottomColor = util.colorToRgb(opts.borderBottomColor || opts.borderColor || 0x000000);\n  this.borderLeftWidth = opts.borderLeftWidth || opts.borderWidth || 0;\n  this.borderLeftColor = util.colorToRgb(opts.borderLeftColor || opts.borderColor || 0x000000);\n  this.paddingTop += this.borderTopWidth;\n  this.paddingRight += this.borderRightWidth;\n  this.paddingBottom += this.borderBottomWidth;\n  this.paddingLeft += this.borderLeftWidth;\n  this.minHeight = opts.minHeight || 0;\n}","map":{"version":3,"sources":["/mnt/c/Users/Venkatesh/Documents/6th Sem/Web Dev/project/resume-generator/node_modules/pdfjs/lib/cell.js"],"names":["Fragment","require","util","ops","module","exports","Cell","constructor","doc","parent","opts","_pending","_firstPage","_firstRendered","_drawBorders","_cursor","clone","applyOpts","call","_previousStartX","startX","x","paddingLeft","width","paddingRight","bottomOffset","paddingBottom","borderBottomWidth","_startRendering","_pageBreak","level","insideBreak","renderHeight","_startY","bottom","actualHeight","y","contents","offset","_doc","height","idx","_contents","indexOf","_bgLayerRef","take","_endLayerRef","length","splice","paddingTop","borderTopWidth","_createBackground","_parent","undefined","unshift","cursorOffset","_startContentObject","_write","q","cm","push","apply","Q","hasTopBorder","hasBottomBorder","hasBorder","borderRightWidth","borderLeftWidth","backgroundColor","layer","pop","bgLayerIndex","chunk","sc","re","outerWidth","f","borderColor","borderWidth","rgbEqual","borderLeftColor","SC","w","y1","y2","S","borderRightColor","borderTopColor","x1","x2","borderBottomColor","startY","_start","_currentContent","_startPage","minHeight","doesFit","_ended","Promise","resolve","_end","end","prototype","padding","colorToRgb"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Fragment = require('./fragment')\nconst util = require('./util')\nconst ops = require('./ops')\n\nmodule.exports = class Cell extends Fragment {\n  constructor(doc, parent, opts) {\n    super(doc, parent)\n\n    this._pending = []\n    this._firstPage = true\n    this._firstRendered = false\n    this._drawBorders = true\n\n    // create new cursor for cell context\n    // const previousCursor = this._cursor\n    this._cursor = this._cursor.clone()\n\n    applyOpts.call(this, opts)\n\n    this._previousStartX = this._cursor.startX\n    if (this.x) {\n      this._cursor.startX = this.x\n    }\n\n    // adjust cursor according to cell padding\n    this._cursor.startX += this.paddingLeft\n    this._cursor.width  -= this.paddingLeft + this.paddingRight\n    this._cursor.bottomOffset = this.paddingBottom - this.borderBottomWidth\n\n    this._startRendering = null\n  }\n\n  /// private API\n\n  async _pageBreak(level, insideBreak) {\n    const renderHeight = this._startY - this._cursor.bottom\n    const actualHeight = this._startY - this._cursor.y\n\n    let contents, offset\n    if (!insideBreak && this._firstPage && renderHeight / this._doc.height <= .15) {\n      // move already rendered cell content to the next page if the current cell height does only\n      // make up about 10% of the total page height\n      const idx = this._doc._contents.indexOf(this._bgLayerRef)\n      const take = this._endLayerRef ? (this._doc._contents.indexOf(this._endLayerRef) - idx + 1) : (this._doc._contents.length - idx)\n      contents = this._doc._contents.splice(idx, take)\n      offset = actualHeight - this.paddingTop + this.borderTopWidth\n    } else {\n      // on page breaks, always draw background until the current bottom\n      this._cursor.y = this._cursor.bottom - this.paddingBottom\n\n      // create background on each page break\n      await this._createBackground(!this._firstRendered, false)\n      this._firstRendered = true\n    }\n\n    this._firstPage = false\n\n    if (this._parent) {\n      await this._parent._pageBreak(level + 1, contents === undefined)\n    }\n\n    // By pushing the following at the beginning of the cell's pending queue instead of executing\n    // it directly, we ensure that is executed just before the cell's content continues rendering\n    // on the next page - especially when cells are appended horizontally into rows.\n    this._pending.unshift(async () => {\n      // reset some cursor values\n      this._cursor.x = this._cursor.startX\n      this._cursor.cursorOffset = 0\n\n      if (contents) {\n        await this._doc._startContentObject()\n        await this._doc._write(ops.q() + ops.cm(1, 0, 0, 1, 0, this._cursor.y - this._startY))\n        this._doc._contents.push.apply(this._doc._contents, contents)\n\n        await this._doc._startContentObject()\n        await this._doc._write(ops.Q())\n\n        this._bgLayerRef = null\n      }\n\n      this._startY = this._cursor.y\n\n      if (offset > 0) {\n        this._cursor.y -= offset\n      }\n\n      // apply padding after page break (but only to most inner cell)\n      if (level === 1) {\n        this._cursor.y -= this.paddingTop - this.borderTopWidth\n        this._cursor.bottomOffset = this.paddingBottom - this.borderBottomWidth\n      }\n\n      // TODO: is there a better way of achieving this?\n      if (this._pending.length === 0) {\n        this._cursor.y = this._startY\n      }\n    })\n  }\n\n  async _createBackground(hasTopBorder, hasBottomBorder) {\n    // if there is no backgroundColor, it is not necessary to create the background layer\n    const hasBorder = this._drawBorders && (this.borderTopWidth > 0 || this.borderRightWidth > 0 || this.borderBottomWidth > 0 || this.borderLeftWidth > 0)\n    if (!this.backgroundColor && !hasBorder) {\n      return\n    }\n\n    // start a new content object for the background and border layer\n    await this._doc._startContentObject(null, true)\n\n    // put the background layer behind the cell\n    const layer = this._doc._contents.pop()\n    const bgLayerIndex = this._bgLayerRef ? this._doc._contents.indexOf(this._bgLayerRef) : 0\n    this._doc._contents.splice(bgLayerIndex, 0, layer)\n\n    // calculate background height\n    let height = this._startY - this._cursor.y\n    const bottom = this._cursor.bottom - this.paddingBottom + this.borderBottomWidth\n    if (this._startY - height < bottom) {\n      // if background height goes beyond bottom of document, trim it to the bottom\n      height = this._startY - bottom\n    }\n\n    let chunk = ops.q() // save graphics state\n\n    if (this.backgroundColor) {\n      // write background\n      chunk += ops.sc(this.backgroundColor[0], this.backgroundColor[1], this.backgroundColor[2]) // non-stroking color\n             + ops.re(this._cursor.startX - this.paddingLeft, this._startY - height, this.outerWidth, height) // rectangle\n             + ops.f() // fill path\n    }\n\n    if (this._drawBorders) {\n      let borderColor = null\n      let borderWidth = null\n\n      // draw left border\n      if (this.borderLeftWidth > 0) {\n        if (!borderColor || !util.rgbEqual(borderColor, this.borderLeftColor)) {\n          chunk += ops.SC(this.borderLeftColor[0], this.borderLeftColor[1], this.borderLeftColor[2]) // stroking color\n          borderColor = this.borderLeftColor\n        }\n\n        if (borderWidth !== this.borderLeftWidth) {\n          chunk += ops.w(this.borderLeftWidth) // line width\n          borderWidth = this.borderLeftWidth\n        }\n\n        const x = this._cursor.startX - this.paddingLeft + this.borderLeftWidth / 2\n        const y1 = this._startY\n        const y2 = this._startY - height\n\n        chunk += ops.S(x, y1, 'm', x, y2, 'l') // fill path\n      }\n\n      // draw right border\n      if (this.borderRightWidth > 0) {\n        if (!borderColor || !util.rgbEqual(borderColor, this.borderRightColor)) {\n          chunk += ops.SC(this.borderRightColor[0], this.borderRightColor[1], this.borderRightColor[2]) // stroking color\n          borderColor = this.borderRightColor\n        }\n\n        if (borderWidth !== this.borderRightWidth) {\n          chunk += ops.w(this.borderRightWidth) // line width\n          borderWidth = this.borderRightWidth\n        }\n\n        const x = this._cursor.startX - this.paddingLeft + this.outerWidth - this.borderRightWidth / 2\n        const y1 = this._startY\n        const y2 = this._startY - height\n\n        chunk += ops.S(x, y1, 'm', x, y2, 'l') // fill path\n      }\n\n      // draw top border\n      if (hasTopBorder && this.borderTopWidth > 0) {\n        if (!borderColor || !util.rgbEqual(borderColor, this.borderTopColor)) {\n          chunk += ops.SC(this.borderTopColor[0], this.borderTopColor[1], this.borderTopColor[2]) // stroking color\n          borderColor = this.borderTopColor\n        }\n\n        if (borderWidth !== this.borderTopWidth) {\n          chunk += ops.w(this.borderTopWidth) // line width\n          borderWidth = this.borderTopWidth\n        }\n\n        const x1 = this._cursor.startX - this.paddingLeft\n        const x2 = x1 + this.outerWidth\n        const y = this._startY - this.borderTopWidth / 2\n\n        chunk += ops.S(x1, y, 'm', x2, y, 'l') // fill path\n      }\n\n      // draw bottom border\n      if (hasBottomBorder && this.borderBottomWidth > 0) {\n        if (!borderColor || !util.rgbEqual(borderColor, this.borderBottomColor)) {\n          chunk += ops.SC(this.borderBottomColor[0], this.borderBottomColor[1], this.borderBottomColor[2]) // stroking color\n          borderColor = this.borderBottomColor\n        }\n\n        if (borderWidth !== this.borderBottomWidth) {\n          chunk += ops.w(this.borderBottomWidth) // line width\n          borderWidth = this.borderBottomWidth\n        }\n\n        const x1 = this._cursor.startX - this.paddingLeft\n        const x2 = x1 + this.outerWidth\n        const y = this._startY - height + this.borderBottomWidth / 2\n\n        chunk += ops.S(x1, y, 'm', x2, y, 'l') // fill path\n      }\n    }\n\n    if (chunk.length > 0) {\n      chunk += ops.Q() // restore graphics state\n      await this._doc._write(chunk)\n    }\n\n    // for succeeding pages put background layers at index 0 (for bgLayerRef === null, index 0\n    // will be used)\n    this._bgLayerRef = null\n\n    // update startAt to take page break into account\n    this._startY = this._cursor.startY\n  }\n\n  async _start() {\n    if (!this._doc._currentContent) {\n      await this._doc._startPage()\n    }\n\n    if (this.minHeight > 0 && !this._parent._cursor.doesFit(this.minHeight)) {\n      await this._parent._pageBreak(1)\n    }\n\n    if (this.y !== undefined) {\n      this._cursor.y = this.y\n    }\n\n    // Note: We could call `doesFit(this.minHeight)` here again to test whether the cell fits on the\n    // newly created page. However, instead of throwing an error, when the minHeight is greater than\n    // the document height, the minHeight is bounded to the documents height.\n\n    this._startY = this._cursor.y\n\n    this._cursor.x = this._cursor.startX\n    this._cursor.y -= this.paddingTop\n\n    this.outerWidth = this._cursor.width + this.paddingLeft + this.paddingRight\n\n    // start a new content layer for cells\n    // save the current layer ref, this will be used to place the background and border layer\n    // after the cell has been rendered\n    // Note: saving the index directly would  not work for nested rendering tasks\n    this._bgLayerRef = await this._doc._startContentObject(null, true)\n\n    // block execution until the row knows about all its cells, otherwise it is possible that the\n    // rendering scheduler (_pending) removes this._pending before the cell's end got called\n    if (!this._ended) {\n      await new Promise(resolve => {this._startRendering = resolve})\n    }\n  }\n\n  async _end() {\n    // apply bottom padding\n    this._cursor.y -= this.paddingBottom\n\n    const height = this._startY - this._cursor.y\n    if (height < this.opts.minHeight) {\n      this._cursor.y -= this.opts.minHeight - height\n    }\n\n    // create final createBackground\n    await this._createBackground(!this._firstRendered, true)\n\n    // restore cursor\n    this._cursor.x = this._previousStartX\n  }\n\n  end() {\n    if (this._startRendering) {\n      this._startRendering()\n    }\n    return Fragment.prototype.end.call(this)\n  }\n}\n\nfunction applyOpts(opts) {\n  this.opts = opts\n\n  if ('width' in opts) {\n    this._cursor.width = opts.width\n  }\n\n  if ('x' in opts) {\n    this.x = opts.x\n  }\n\n  if ('y' in opts) {\n    this.y = opts.y\n  }\n\n  this.paddingTop    = opts.paddingTop    || opts.padding || 0\n  this.paddingRight  = opts.paddingRight  || opts.padding || 0\n  this.paddingBottom = opts.paddingBottom || opts.padding || 0\n  this.paddingLeft   = opts.paddingLeft   || opts.padding || 0\n\n  // background creation callback\n  this.backgroundColor = util.colorToRgb(opts.backgroundColor)\n\n  this.borderTopWidth = opts.borderTopWidth || opts.borderWidth || 0\n  this.borderTopColor = util.colorToRgb(opts.borderTopColor || opts.borderColor || 0x000000)\n\n  this.borderRightWidth = opts.borderRightWidth || opts.borderWidth || 0\n  this.borderRightColor = util.colorToRgb(opts.borderRightColor || opts.borderColor || 0x000000)\n\n  this.borderBottomWidth = opts.borderBottomWidth || opts.borderWidth || 0\n  this.borderBottomColor = util.colorToRgb(opts.borderBottomColor || opts.borderColor || 0x000000)\n\n  this.borderLeftWidth = opts.borderLeftWidth || opts.borderWidth || 0\n  this.borderLeftColor = util.colorToRgb(opts.borderLeftColor || opts.borderColor || 0x000000)\n\n  this.paddingTop    += this.borderTopWidth\n  this.paddingRight  += this.borderRightWidth\n  this.paddingBottom += this.borderBottomWidth\n  this.paddingLeft   += this.borderLeftWidth\n\n  this.minHeight = opts.minHeight || 0\n}"]},"metadata":{},"sourceType":"script"}