{"ast":null,"code":"'use strict';\n\nconst Cursor = require('./cursor');\n\nconst Fragment = require('./fragment');\n\nconst ops = require('./ops');\n\nconst PDF = require('./object');\n\nconst Readable = require('readable-stream');\n\nconst {\n  v4: uuidv4\n} = require('uuid');\n\nconst util = require('./util');\n\nconst ContentChunk = require('./content');\n\nconst ExternalDocument = require('./external');\n\nconst Font = require('./font/base'); // constants\n\n\nconst RESOLVE = Promise.resolve();\n\nclass Document extends Readable {\n  constructor(opts) {\n    if (!opts) {\n      opts = {};\n    } // readable stream options\n\n\n    super({\n      highWaterMark: opts.highWaterMark || 16384 // 16kB\n\n    });\n    this.version = '1.6';\n    this.info = Object.assign({}, opts.properties, {\n      id: uuidv4()\n    });\n    this.width = opts.width || 595.296;\n    this.height = opts.height || 841.896;\n    this._nextObjectId = 1;\n    this._xref = new PDF.Xref();\n    this._reading = false; // wheater someone is reading data from the underlying Readable\n\n    this._length = 0; // keeps track of the total document length (in byte)\n    // header\n\n    const header = `%PDF-${this.version}\\n` // The PDF format mandates that we add at least 4 commented binary characters\n    // (ASCII value >= 128), so that generic tools have a chance to detect\n    // that it's a binary file\n    + '%\\xFF\\xFF\\xFF\\xFF\\n\\n'; // a backlog of pending operations\n\n    this._pending = [() => this._write(header)]; // this is the current operation that is executed (operations are executed sequentially)\n\n    this._pending.current = null; // init default styling opts\n\n    this.defaultFont = opts.font || require('../font/Helvetica');\n    this.defaultFontSize = opts.fontSize || 11;\n    this.defaultColor = opts.color && util.colorToRgb(opts.color) || [0, 0, 0];\n    this.defaultLineHeight = opts.lineHeight || 1.15;\n\n    if (!Font.isFont(this.defaultFont)) {\n      throw new TypeError('opts.font must be set to a valid default font');\n    } // create document and page font dict\n\n\n    this._fonts = {};\n    this._xobjects = {};\n    this._pageFonts = {};\n    this._annotations = []; // these properties are used to keep track of used Font and Image objects and assign ids to\n    // them in a document-scoped way\n\n    this._aliases = new AliasGenerator();\n    this._mapping = new WeakMap(); // a page could consist out of multiple content chunks, which are keept track of using the\n    // following properties\n\n    this._currentContent = null;\n    this._contents = [];\n    this._contentObjCreator = null; // this array can be used to register callbacks that are executed when finalizing the document\n    // e.g. rendering the total page count\n\n    this._finalize = [];\n    this._header = this._footer = this._template = null; // init cursor\n    // TODO: test for valid values\n\n    const padding = opts.padding >= 0 ? opts.padding : 20;\n    this.paddingTop = util.defaults(opts.paddingTop, padding);\n    this.paddingBottom = util.defaults(opts.paddingBottom, padding);\n    this.paddingLeft = util.defaults(opts.paddingLeft, padding);\n    this.paddingRight = util.defaults(opts.paddingRight, padding);\n    this._cursor = new Cursor(this.width - this.paddingLeft - this.paddingRight, this.height - this.paddingTop - this.paddingBottom, // width, height\n    this.paddingLeft, this.height - this.paddingTop // x, y\n    ); // init pages catalog\n\n    this._pages = new PDF.Array();\n    this._pagesObj = new PDF.Object('Pages');\n\n    this._registerObject(this._pagesObj); // init destinations name tree\n\n\n    this._destinations = new PDF.NameTree(); // init outlines hierarchy\n\n    this._outlines = []; // init color space\n\n    this._colorSpace = new PDF.Object();\n    const iccProfile = require('./sRGB_IEC61966-2-1_black_scaled') + '~>';\n    this._colorSpace.content = 'stream\\n' + iccProfile + '\\nendstream\\n';\n\n    this._colorSpace.prop('Length', iccProfile.length);\n\n    this._colorSpace.prop('N', 3);\n\n    this._colorSpace.prop('Alternate', 'DeviceRGB'); // this._colorSpace.prop('Filter', new PDF.Array([\n    //   new PDF.Name('ASCII85Decode'), new PDF.Name('FlateDecode')\n    // ]))\n\n\n    this._colorSpace.prop('Filter', new PDF.Name('ASCII85Decode'));\n\n    this._registerObject(this._colorSpace);\n\n    this._currentColorSpace = '/CS1'; // start to work the _pending queue\n\n    this._next();\n\n    Fragment.prototype._init.call(this, this, this);\n  } /// private API\n\n\n  _next() {\n    // return if there is already an operation worked on\n    if (this._pending.current) {\n      return this._pending.current;\n    } // variables used to traverse the nested queue\n\n\n    let parent = this._pending;\n    let next = parent[0]; // if there is nothing in the queue, we are done here\n\n    if (!next) {\n      return RESOLVE;\n    } // the operation queue is a nested array, e.g.: [op1, [op2, op3, [ op4 ]], op5]\n    // it is therefore necessary traverse the first element until the first non array element\n    // is encountered\n\n\n    while (Array.isArray(next)) {\n      // if the first element is an empty array, remove it and start over\n      if (next.length === 0) {\n        parent.shift();\n        return this._next();\n      }\n\n      parent = next;\n      next = next[0];\n    } // remove next from the queue\n\n\n    parent.shift(); // TODO: still necessary?\n    // if (!next) {\n    //   return this._next()\n    // }\n    // return and set the current operation that is being executed\n\n    return this._pending.current = next().then(() => {\n      // once the execution finished, continue in the queue\n      this._pending.current = null;\n      return this._next();\n    });\n  } // This is method is used by Node.js stream.Readable class, which we inherit from.\n  // The method is called, if data is available from the resource, which means that we should\n  // start pushing data into the read queue (using `this.push(dataChunk)`). It should continue\n  // reading from the resoruce and pushing data until `this.push()` return `false`. Only when it\n  // is called again aft it has stopped should it resume pushing additional data onto the\n  // read queue.\n\n\n  _read()\n  /* size */\n  {\n    this._reading = true;\n    this.emit('read');\n  } // This method is used to push data onto the read queue. If the Readable stream is currently\n  // not read from, the writing is postponed.\n\n\n  _write(chunk) {\n    if (this._reading) {\n      if (!this.push(chunk, 'binary')) {\n        this._reading = false;\n      }\n\n      this._length += chunk.length;\n      return RESOLVE;\n    } else {\n      return new Promise(resolve => {\n        this.once('read', () => {\n          resolve(this._write(chunk));\n        });\n      });\n    }\n  }\n\n  _useFont(font) {\n    let alias;\n\n    if (this._mapping.has(font)) {\n      alias = this._mapping.get(font); // if the alias exists but is now blocked (e.g. because of having set a new template with\n      // colliding aliases), remove the mapping and unset the alias to force creation of a new one\n\n      if (this._aliases.isBlocked(alias)) {\n        this._mapping.delete(font);\n\n        alias = undefined;\n      }\n    }\n\n    if (!alias) {\n      alias = new PDF.Name(this._aliases.next('F'));\n\n      this._mapping.set(font, alias);\n\n      const fontObj = new PDF.Object('Font');\n      this._fonts[alias] = {\n        f: font.instance(),\n        o: fontObj\n      };\n\n      this._registerObject(fontObj);\n    }\n\n    if (this._currentContent && !(alias in this._currentContent._fonts)) {\n      this._currentContent._fonts[alias] = this._fonts[alias].o.toReference();\n    }\n\n    return alias;\n  }\n\n  _fontAlias(instance) {\n    return this._useFont(instance.parent);\n  }\n\n  _fontInstance(font) {\n    return this._fonts[this._useFont(font)].f;\n  }\n\n  _useXObject(xobj) {\n    let alias;\n\n    if (this._mapping.has(xobj)) {\n      alias = this._mapping.get(xobj); // if the alias exists but is now blocked (e.g. because of having set a new template with\n      // colliding aliases), remove the mapping and unset the alias to force creation of a new one\n\n      if (this._aliases.isBlocked(alias)) {\n        this._mapping.delete(xobj);\n\n        alias = undefined;\n      }\n    }\n\n    if (!alias) {\n      alias = new PDF.Name(this._aliases.next('X'));\n\n      this._mapping.set(xobj, alias);\n\n      const xobjObjs = [];\n\n      for (let i = 0; i < xobj.xobjCount; ++i) {\n        const xobjObj = new PDF.Object('XObject');\n\n        this._registerObject(xobjObj);\n\n        xobjObjs.push(xobjObj);\n      }\n\n      this._xobjects[alias] = {\n        x: xobj,\n        o: xobjObjs\n      };\n    }\n\n    if (this._currentContent && !(alias in this._currentContent._xobjects)) {\n      for (let i = 0; i < this._xobjects[alias].o.length; ++i) {\n        this._currentContent._xobjects[alias + '.' + i] = this._xobjects[alias].o[i].toReference();\n      }\n    }\n\n    const aliases = [];\n\n    for (let i = 0; i < this._xobjects[alias].o.length; ++i) {\n      aliases.push(alias + '.' + i);\n    }\n\n    return aliases;\n  }\n\n  async _startPage() {\n    if (this._currentPage) {\n      throw new Error('There is already a started page');\n    }\n\n    const page = this._currentPage = new PDF.Object('Page');\n\n    this._pages.push(page.toReference());\n\n    if (this._template) {\n      const taken = {};\n\n      for (const alias in this._template.colorSpaces) {\n        taken[alias] = null;\n      }\n\n      let i = 1;\n\n      for (1; ('/CS' + i in taken); ++i) {}\n\n      this._currentColorSpace = '/CS' + i;\n    } else {\n      this._currentColorSpace = '/CS1';\n    }\n\n    await this._startContentObject();\n\n    if (this._header) {\n      let chunk = '';\n\n      for (const i in this._header._objects) {\n        const obj = this._header._objects[i];\n        const alias = new PDF.Name(this._aliases.next('H'));\n        this._currentContent._xobjects[alias] = obj.toReference();\n        chunk += ops.Do(alias);\n      }\n\n      await this._write(chunk);\n      await this._header._render();\n    }\n\n    if (this._footer) {\n      let chunk = '';\n\n      for (const i in this._footer._objects) {\n        const obj = this._footer._objects[i];\n        const alias = new PDF.Name(this._aliases.next('F'));\n        this._currentContent._xobjects[alias] = obj.toReference();\n        chunk += ops.Do(alias);\n      }\n\n      await this._write(chunk);\n      await this._footer._render();\n    }\n\n    this._cursor.reset();\n\n    if (this._header) {\n      this._cursor.y -= this._header.height;\n    }\n\n    if (this._footer) {\n      this._cursor.bottomOffset = this._footer.height;\n    }\n  }\n\n  async _endPage() {\n    if (!this._currentPage) {\n      return;\n    }\n\n    await this._endContentObject();\n    const fonts = new PDF.Dictionary({});\n    const xobjects = new PDF.Dictionary({});\n\n    for (const content of this._contents) {\n      for (const alias in content._fonts) {\n        fonts.add(alias, content._fonts[alias]);\n      }\n\n      for (const alias in content._xobjects) {\n        xobjects.add(alias, content._xobjects[alias]);\n      }\n    }\n\n    const page = this._currentPage;\n    page.prop('Parent', this._pagesObj.toReference());\n    const colorSpace = new PDF.Dictionary({\n      [this._currentColorSpace]: new PDF.Array([new PDF.Name('ICCBased'), this._colorSpace.toReference()])\n    });\n    const resources = new PDF.Dictionary({\n      ColorSpace: colorSpace,\n      ProcSet: new PDF.Array([new PDF.Name('PDF'), new PDF.Name('Text'), new PDF.Name('ImageB'), new PDF.Name('ImageC'), new PDF.Name('ImageI')]),\n      Font: fonts,\n      XObject: xobjects\n    });\n    page.prop('Resources', resources);\n\n    if (this._annotations.length > 0) {\n      page.prop('Annots', new PDF.Array(this._annotations));\n      this._annotations = [];\n    }\n\n    const contents = this._contents.map(c => c._object.toReference());\n\n    page.prop('Contents', new PDF.Array(contents));\n\n    if (this._template) {\n      contents.unshift.apply(contents, this._template.contents);\n\n      for (const alias in this._template.colorSpaces) {\n        colorSpace.dictionary[alias] = this._template.colorSpaces[alias];\n      }\n\n      for (const alias in this._template.fonts) {\n        fonts.dictionary[alias] = this._template.fonts[alias];\n      }\n\n      for (const alias in this._template.xobjects) {\n        xobjects.dictionary[alias] = this._template.xobjects[alias];\n      }\n\n      const extGStates = new PDF.Dictionary({});\n\n      for (const alias in this._template.extGStates) {\n        extGStates.dictionary[alias] = this._template.extGStates[alias];\n      }\n\n      if (extGStates.length > 0) {\n        resources.set('ExtGState', extGStates);\n      }\n\n      const shadings = new PDF.Dictionary({});\n\n      for (const alias in this._template.shadings) {\n        shadings.dictionary[alias] = this._template.shadings[alias];\n      }\n\n      if (shadings.length > 0) {\n        resources.set('Shading', shadings);\n      }\n    }\n\n    await this._writeObject(page);\n    this._currentContent = this._currentPage = null;\n    this._contents.length = 0;\n\n    if (this._template && this._template.firstPageOnly) {\n      this._template = null;\n    }\n  }\n\n  async _pageBreak()\n  /* level */\n  {\n    if (!this._currentPage) {\n      await this._startPage();\n    }\n\n    await this._cursor.reset();\n    await this._endPage();\n    await this._startPage();\n  }\n\n  async _startContentObject(obj, force) {\n    // do not create new content object, if current content object is still empty\n    // 16 = /CS1 CS\n    //      /CS1 cs\n    if (!force && this._length - 16 == this._contentStart) {\n      return this._currentContent;\n    }\n\n    if (this._currentContent) {\n      await this._endContentObject();\n    }\n\n    if (this._contentObjCreator) {\n      obj = this._contentObjCreator();\n    }\n\n    const content = this._currentContent = new ContentChunk(this, obj);\n\n    this._contents.push(content);\n\n    this._xref.add(content._object.id, {\n      offset: this._length,\n      obj: content._object\n    });\n\n    let chunk = content._object.id + ' ' + content._object.rev + ' obj\\n' + content._object.properties.toString() + '\\n' + 'stream\\n';\n    this._contentStart = this._length + chunk.length; // set color space\n\n    chunk += ops.CS(this._currentColorSpace) + ops.cs(this._currentColorSpace);\n    await this._write(chunk);\n    return content;\n  }\n\n  async _endContentObject() {\n    if (!this._currentContent) {\n      return;\n    }\n\n    this._currentContent._length.content = this._length - this._contentStart - 1;\n\n    if (this._currentContent._length.content < 0) {\n      this._currentContent._length.content = 0;\n    }\n\n    const chunk = 'endstream\\nendobj\\n\\n';\n    await this._write(chunk);\n    await this._writeObject(this._currentContent._length);\n    this._currentContent = null;\n  }\n\n  _registerObject(object, force) {\n    if (object instanceof PDF.Stream) {\n      object = object.object;\n    }\n\n    if (!force && object.id) {\n      return;\n    }\n\n    object.id = this._nextObjectId;\n    this._nextObjectId++;\n  }\n\n  _writeObject(object) {\n    if (object instanceof PDF.Stream) {\n      object = object.object;\n    }\n\n    if (!object.id) {\n      this._registerObject(object);\n    }\n\n    this._xref.add(object.id, {\n      offset: this._length,\n      obj: object\n    });\n\n    return this._write(object.toString() + '\\n\\n');\n  }\n\n  _updateOutlinesCount(id) {\n    if (this._outlines[id].data.count < 1) {\n      this._outlines[id].data.count -= 1;\n\n      this._outlines[id].prop('Count', this._outlines[id].data.count);\n    } else {\n      this._outlines[id].data.count = -1;\n\n      this._outlines[id].prop('Count', this._outlines[id].data.count);\n    }\n\n    const nextParent = this._outlines[id].data.parentIndex;\n\n    if (nextParent !== undefined) {\n      this._updateOutlinesCount(nextParent);\n    }\n  } // public API\n\n\n  async end() {\n    await Fragment.prototype.end.call(this);\n    await this._next();\n    await this._endPage();\n\n    for (const fn of this._finalize) {\n      await fn();\n    }\n\n    this._pagesObj.prop('MediaBox', new PDF.Array([0, 0, this.width, this.height]));\n\n    this._pagesObj.prop('Kids', this._pages);\n\n    this._pagesObj.prop('Count', this._pages.length);\n\n    await this._writeObject(this._pagesObj);\n    await this._writeObject(this._colorSpace);\n\n    for (const alias in this._fonts) {\n      const font = this._fonts[alias];\n      await font.f.write(this, font.o);\n    }\n\n    for (const alias in this._xobjects) {\n      const xobj = this._xobjects[alias];\n      await xobj.x.write(this, xobj.o);\n    }\n\n    const catalog = new PDF.Object('Catalog');\n    catalog.prop('Pages', this._pagesObj.toReference());\n\n    if (this._destinations.length > 0) {\n      const destsObj = new PDF.Object();\n      destsObj.prop(\"Dests\", this._destinations);\n      await this._writeObject(destsObj);\n      catalog.prop('Names', destsObj.toReference());\n    } //Write outlines hierarchy if there are outlines\n\n\n    if (this._outlines.length > 0) {\n      for (let i = 0; i < this._outlines.length; i += 1) {\n        await this._writeObject(this._outlines[i]);\n      }\n\n      catalog.prop('Outlines', this._outlines[0].toReference());\n    }\n\n    await this._writeObject(catalog); // to support random access to individual objects, a PDF file\n    // contains a cross-reference table that can be used to locate\n    // and directly access pages and other important objects within the file\n\n    const startxref = this._length;\n    await this._write(this._xref.toString()); // trailer\n\n    const objectsCount = this._nextObjectId - 1;\n    const trailer = new PDF.Trailer(objectsCount + 1, catalog, this.info);\n    await this._write(trailer.toString() + '\\n'); // startxref\n\n    await this._write('startxref\\n' + startxref + '\\n%%EOF'); // close readable stream\n\n    this.push(null);\n  }\n\n  asBuffer(opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = undefined;\n    }\n\n    const shouldEnd = !opts || opts.end !== false;\n    let p = new Promise((resolve, reject) => {\n      const chunks = [];\n      this.on('data', chunk => chunks.push(chunk));\n      this.on('end', () => resolve(Buffer.concat(chunks)));\n      this.on('error', reject);\n\n      if (shouldEnd) {\n        this.end();\n      }\n    });\n\n    if (typeof callback === 'function') {\n      p = p.then(data => callback(null, data)).catch(callback);\n    }\n\n    return p;\n  }\n\n  header() {\n    const Header = require('./header');\n\n    const ctx = new Header(this, this);\n\n    this._begin(ctx);\n\n    this._pending.push(() => {\n      this._header = ctx;\n      return ctx._start();\n    });\n\n    return ctx;\n  }\n\n  footer() {\n    const Footer = require('./footer');\n\n    const ctx = new Footer(this, this);\n\n    this._begin(ctx);\n\n    this._pending.push(() => {\n      this._footer = ctx;\n      return ctx._start();\n    });\n\n    return ctx;\n  }\n\n  addPagesOf(external) {\n    if (!(external instanceof ExternalDocument)) {\n      throw new TypeError('argument must be of type ExternalDocument');\n    }\n\n    this._begin(null);\n\n    this._pending.push(() => external.write(this));\n  }\n\n  addPageOf(page, external) {\n    if (!(external instanceof ExternalDocument)) {\n      throw new TypeError('argument must be of type ExternalDocument');\n    }\n\n    if (!page || page < 1 || page > external.pageCount) {\n      throw new TypeError('ExternalDocument does not have page ' + page);\n    }\n\n    this._begin(null);\n\n    this._pending.push(() => external.write(this, page));\n  }\n\n  setTemplate(external, firstPageOnly = false) {\n    if (!(external instanceof ExternalDocument)) {\n      throw new TypeError('argument must be of type ExternalDocument');\n    }\n\n    this._begin(null);\n\n    this._pending.push(() => external.setAsTemplate(this, firstPageOnly));\n  }\n\n  outline(title, destination, parent) {\n    // Skip empty titles and/or destination\n    if (title === undefined || destination === undefined) return; // Create the root outline the first time this method is called\n\n    if (this._outlines.length === 0) {\n      this._outlines[0] = new PDF.Object('Outlines');\n      this._outlines[0].data = {\n        type: 'Outlines'\n      };\n\n      this._registerObject(this._outlines[0]);\n    } // Find parent item\n\n\n    let parentIndex;\n\n    if (typeof parent === 'number' && parent >= 0 && parent <= this._outlines.length) {\n      // the user provided a valid index number: use it as the parentIndex\n      parentIndex = parent;\n    } else {\n      // the user did not provide a valid index number: search for it in the outline array\n      // if it is not found, create the corresponding parent at root level\n      if (parent === undefined || parent === '') {\n        parentIndex = 0;\n      } else {\n        parentIndex = this._outlines.findIndex((item, index) => item.data.title === parent);\n        if (parentIndex === -1) parentIndex = this.outline(parent, destination);\n      }\n    } // Find siblings\n\n\n    let siblingsIndexes = this._outlines.reduce((result, item, index) => {\n      if (index !== 0 && item.data.parentIndex === parentIndex) result.push(index);\n      return result;\n    }, []); // Create item\n\n\n    const outline = new PDF.Object();\n    outline.data = {\n      title,\n      destination,\n      parent\n    };\n    outline.prop('Title', new PDF.String(title));\n    outline.prop('Parent', this._outlines[parentIndex].toReference());\n    outline.prop('A', new PDF.Dictionary({\n      S: 'GoTo',\n      D: new PDF.String(destination)\n    }));\n\n    this._registerObject(outline);\n\n    const outlineIndex = this._outlines.push(outline) - 1; // Chain to siblings\n\n    const prevSiblingIndex = siblingsIndexes[siblingsIndexes.length - 1];\n\n    if (prevSiblingIndex > 0) {\n      // Next\n      this._outlines[prevSiblingIndex].data.nextId = outlineIndex;\n\n      this._outlines[prevSiblingIndex].prop('Next', this._outlines[outlineIndex].toReference()); // Prev\n\n\n      this._outlines[outlineIndex].data.prevId = prevSiblingIndex;\n\n      this._outlines[outlineIndex].prop('Prev', this._outlines[prevSiblingIndex].toReference());\n    } // Chain to parents\n\n\n    this._outlines[outlineIndex].data.parentIndex = parentIndex;\n\n    if (siblingsIndexes.length === 0) {\n      // First\n      this._outlines[parentIndex].data.firstIndex = outlineIndex;\n\n      this._outlines[parentIndex].prop('First', this._outlines[outlineIndex].toReference());\n    } // Last\n\n\n    this._outlines[parentIndex].data.lastIndex = outlineIndex;\n\n    this._outlines[parentIndex].prop('Last', this._outlines[outlineIndex].toReference()); // Count(s)\n\n\n    this._updateOutlinesCount(parentIndex);\n\n    return outlineIndex;\n  }\n\n}\n\nObject.assign(Document.prototype, {\n  _begin: Fragment.prototype._begin,\n  _end: Fragment.prototype._end,\n  _opts: Fragment.prototype._opts,\n  text: Fragment.prototype.text,\n  cell: Fragment.prototype.cell,\n  table: Fragment.prototype.table,\n  image: Fragment.prototype.image,\n  pageBreak: Fragment.prototype.pageBreak,\n  op: Fragment.prototype.op,\n  destination: Fragment.prototype.destination\n});\n\nclass AliasGenerator {\n  constructor() {\n    this.nextId = {};\n    this.blocked = new Set();\n  }\n\n  next(prefix) {\n    if (!(prefix in this.nextId)) {\n      this.nextId[prefix] = 1;\n    }\n\n    let next;\n\n    do {\n      next = prefix + this.nextId[prefix]++;\n    } while (this.blocked.has(next));\n\n    return next;\n  }\n\n  block(alias) {\n    alias = String(alias);\n\n    if (alias[0] === '/') {\n      alias = alias.slice(1);\n    }\n\n    this.blocked.add(alias);\n  }\n\n  isBlocked(alias) {\n    alias = String(alias);\n\n    if (alias[0] === '/') {\n      alias = alias.slice(1);\n    }\n\n    return this.blocked.has(alias);\n  }\n\n  reset(prefix) {\n    this.nextId[prefix] = 1;\n  }\n\n}\n\nmodule.exports = Document;","map":{"version":3,"sources":["/mnt/c/Users/Venkatesh/Documents/6th Sem/Web Dev/project/resume-generator/node_modules/pdfjs/lib/document.js"],"names":["Cursor","require","Fragment","ops","PDF","Readable","v4","uuidv4","util","ContentChunk","ExternalDocument","Font","RESOLVE","Promise","resolve","Document","constructor","opts","highWaterMark","version","info","Object","assign","properties","id","width","height","_nextObjectId","_xref","Xref","_reading","_length","header","_pending","_write","current","defaultFont","font","defaultFontSize","fontSize","defaultColor","color","colorToRgb","defaultLineHeight","lineHeight","isFont","TypeError","_fonts","_xobjects","_pageFonts","_annotations","_aliases","AliasGenerator","_mapping","WeakMap","_currentContent","_contents","_contentObjCreator","_finalize","_header","_footer","_template","padding","paddingTop","defaults","paddingBottom","paddingLeft","paddingRight","_cursor","_pages","Array","_pagesObj","_registerObject","_destinations","NameTree","_outlines","_colorSpace","iccProfile","content","prop","length","Name","_currentColorSpace","_next","prototype","_init","call","parent","next","isArray","shift","then","_read","emit","chunk","push","once","_useFont","alias","has","get","isBlocked","delete","undefined","set","fontObj","f","instance","o","toReference","_fontAlias","_fontInstance","_useXObject","xobj","xobjObjs","i","xobjCount","xobjObj","x","aliases","_startPage","_currentPage","Error","page","taken","colorSpaces","_startContentObject","_objects","obj","Do","_render","reset","y","bottomOffset","_endPage","_endContentObject","fonts","Dictionary","xobjects","add","colorSpace","resources","ColorSpace","ProcSet","XObject","contents","map","c","_object","unshift","apply","dictionary","extGStates","shadings","_writeObject","firstPageOnly","_pageBreak","force","_contentStart","offset","rev","toString","CS","cs","object","Stream","_updateOutlinesCount","data","count","nextParent","parentIndex","end","fn","write","catalog","destsObj","startxref","objectsCount","trailer","Trailer","asBuffer","callback","shouldEnd","p","reject","chunks","on","Buffer","concat","catch","Header","ctx","_begin","_start","footer","Footer","addPagesOf","external","addPageOf","pageCount","setTemplate","setAsTemplate","outline","title","destination","type","findIndex","item","index","siblingsIndexes","reduce","result","String","S","D","outlineIndex","prevSiblingIndex","nextId","prevId","firstIndex","lastIndex","_end","_opts","text","cell","table","image","pageBreak","op","blocked","Set","prefix","block","slice","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Cursor = require('./cursor')\nconst Fragment = require('./fragment')\nconst ops = require('./ops')\nconst PDF = require('./object')\nconst Readable = require('readable-stream')\nconst { v4: uuidv4 } = require('uuid')\nconst util = require('./util')\nconst ContentChunk = require('./content')\nconst ExternalDocument = require('./external')\nconst Font = require('./font/base')\n\n// constants\nconst RESOLVE = Promise.resolve()\n\nclass Document extends Readable {\n  constructor(opts) {\n    if (!opts) {\n      opts = {}\n    }\n\n    // readable stream options\n    super({\n      highWaterMark: opts.highWaterMark || 16384, // 16kB\n    })\n\n    this.version = '1.6'\n    this.info = Object.assign({}, opts.properties, { id: uuidv4() })\n    this.width = opts.width || 595.296\n    this.height = opts.height || 841.896\n\n    this._nextObjectId = 1\n    this._xref = new PDF.Xref()\n    this._reading = false // wheater someone is reading data from the underlying Readable\n    this._length = 0 // keeps track of the total document length (in byte)\n\n    // header\n    const header = `%PDF-${this.version}\\n`\n      // The PDF format mandates that we add at least 4 commented binary characters\n      // (ASCII value >= 128), so that generic tools have a chance to detect\n      // that it's a binary file\n      + '%\\xFF\\xFF\\xFF\\xFF\\n\\n'\n\n    // a backlog of pending operations\n    this._pending = [\n      () => this._write(header)\n    ]\n    // this is the current operation that is executed (operations are executed sequentially)\n    this._pending.current = null\n\n    // init default styling opts\n    this.defaultFont = opts.font || require('../font/Helvetica')\n    this.defaultFontSize = opts.fontSize || 11\n    this.defaultColor = opts.color && util.colorToRgb(opts.color) || [0, 0, 0]\n    this.defaultLineHeight = opts.lineHeight || 1.15\n\n    if (!Font.isFont(this.defaultFont)) {\n      throw new TypeError('opts.font must be set to a valid default font')\n    }\n\n    // create document and page font dict\n    this._fonts = {}\n    this._xobjects = {}\n    this._pageFonts = {}\n    this._annotations = []\n\n    // these properties are used to keep track of used Font and Image objects and assign ids to\n    // them in a document-scoped way\n    this._aliases = new AliasGenerator()\n    this._mapping = new WeakMap()\n\n    // a page could consist out of multiple content chunks, which are keept track of using the\n    // following properties\n    this._currentContent = null\n    this._contents = []\n    this._contentObjCreator = null\n\n    // this array can be used to register callbacks that are executed when finalizing the document\n    // e.g. rendering the total page count\n    this._finalize = []\n\n    this._header = this._footer = this._template = null\n\n    // init cursor\n    // TODO: test for valid values\n    const padding = opts.padding >= 0 ? opts.padding : 20\n    this.paddingTop = util.defaults(opts.paddingTop, padding)\n    this.paddingBottom = util.defaults(opts.paddingBottom, padding)\n    this.paddingLeft = util.defaults(opts.paddingLeft, padding)\n    this.paddingRight = util.defaults(opts.paddingRight, padding)\n\n    this._cursor = new Cursor(\n      this.width - this.paddingLeft - this.paddingRight, this.height - this.paddingTop - this.paddingBottom, // width, height\n      this.paddingLeft, this.height - this.paddingTop // x, y\n    )\n\n    // init pages catalog\n    this._pages = new PDF.Array()\n    this._pagesObj = new PDF.Object('Pages')\n    this._registerObject(this._pagesObj)\n\n    // init destinations name tree\n    this._destinations = new PDF.NameTree()\n\n    // init outlines hierarchy\n    this._outlines = []\n\n    // init color space\n    this._colorSpace = new PDF.Object()\n    const iccProfile = require('./sRGB_IEC61966-2-1_black_scaled') + '~>'\n    this._colorSpace.content = 'stream\\n' + iccProfile + '\\nendstream\\n'\n    this._colorSpace.prop('Length', iccProfile.length)\n    this._colorSpace.prop('N', 3)\n    this._colorSpace.prop('Alternate', 'DeviceRGB')\n    // this._colorSpace.prop('Filter', new PDF.Array([\n    //   new PDF.Name('ASCII85Decode'), new PDF.Name('FlateDecode')\n    // ]))\n    this._colorSpace.prop('Filter', new PDF.Name('ASCII85Decode'))\n    this._registerObject(this._colorSpace)\n    this._currentColorSpace = '/CS1'\n\n    // start to work the _pending queue\n    this._next()\n\n    Fragment.prototype._init.call(this, this, this);\n  }\n\n  /// private API\n\n  _next() {\n    // return if there is already an operation worked on\n    if (this._pending.current) {\n      return this._pending.current\n    }\n\n    // variables used to traverse the nested queue\n    let parent = this._pending\n    let next = parent[0]\n\n    // if there is nothing in the queue, we are done here\n    if (!next) {\n      return RESOLVE\n    }\n\n    // the operation queue is a nested array, e.g.: [op1, [op2, op3, [ op4 ]], op5]\n    // it is therefore necessary traverse the first element until the first non array element\n    // is encountered\n    while (Array.isArray(next)) {\n      // if the first element is an empty array, remove it and start over\n      if (next.length === 0) {\n        parent.shift()\n        return this._next()\n      }\n\n      parent = next\n      next = next[0]\n    }\n\n    // remove next from the queue\n    parent.shift()\n\n    // TODO: still necessary?\n    // if (!next) {\n    //   return this._next()\n    // }\n\n    // return and set the current operation that is being executed\n    return this._pending.current = next().then(() => {\n      // once the execution finished, continue in the queue\n      this._pending.current = null\n      return this._next()\n    })\n  }\n\n  // This is method is used by Node.js stream.Readable class, which we inherit from.\n  // The method is called, if data is available from the resource, which means that we should\n  // start pushing data into the read queue (using `this.push(dataChunk)`). It should continue\n  // reading from the resoruce and pushing data until `this.push()` return `false`. Only when it\n  // is called again aft it has stopped should it resume pushing additional data onto the\n  // read queue.\n  _read(/* size */) {\n    this._reading = true\n    this.emit('read')\n  }\n\n  // This method is used to push data onto the read queue. If the Readable stream is currently\n  // not read from, the writing is postponed.\n  _write(chunk) {\n    if (this._reading) {\n      if (!this.push(chunk, 'binary')) {\n        this._reading = false\n      }\n      this._length += chunk.length\n      return RESOLVE\n    } else {\n      return new Promise(resolve => {\n        this.once('read', () => {\n          resolve(this._write(chunk))\n        })\n      })\n    }\n  }\n\n  _useFont(font) {\n    let alias\n    if (this._mapping.has(font)) {\n      alias = this._mapping.get(font)\n      // if the alias exists but is now blocked (e.g. because of having set a new template with\n      // colliding aliases), remove the mapping and unset the alias to force creation of a new one\n      if (this._aliases.isBlocked(alias)) {\n        this._mapping.delete(font)\n        alias = undefined\n      }\n    }\n\n    if (!alias) {\n      alias = new PDF.Name(this._aliases.next('F'))\n      this._mapping.set(font, alias)\n\n      const fontObj = new PDF.Object('Font')\n      this._fonts[alias] = { f: font.instance(), o: fontObj }\n      this._registerObject(fontObj)\n    }\n\n    if (this._currentContent && !(alias in this._currentContent._fonts)) {\n      this._currentContent._fonts[alias] = this._fonts[alias].o.toReference()\n    }\n\n    return alias\n  }\n\n  _fontAlias(instance) {\n    return this._useFont(instance.parent)\n  }\n\n  _fontInstance(font) {\n    return this._fonts[this._useFont(font)].f\n  }\n\n  _useXObject(xobj) {\n    let alias\n    if (this._mapping.has(xobj)) {\n      alias = this._mapping.get(xobj)\n      // if the alias exists but is now blocked (e.g. because of having set a new template with\n      // colliding aliases), remove the mapping and unset the alias to force creation of a new one\n      if (this._aliases.isBlocked(alias)) {\n        this._mapping.delete(xobj)\n        alias = undefined\n      }\n    }\n\n    if (!alias) {\n      alias = new PDF.Name(this._aliases.next('X'))\n      this._mapping.set(xobj, alias)\n\n      const xobjObjs = []\n      for (let i = 0; i < xobj.xobjCount; ++i) {\n        const xobjObj = new PDF.Object('XObject')\n        this._registerObject(xobjObj)\n        xobjObjs.push(xobjObj)\n      }\n      this._xobjects[alias] = { x: xobj, o: xobjObjs }\n    }\n\n    if (this._currentContent && !(alias in this._currentContent._xobjects)) {\n      for (let i = 0; i < this._xobjects[alias].o.length; ++i) {\n        this._currentContent._xobjects[alias + '.' + i] = this._xobjects[alias].o[i].toReference()\n      }\n    }\n\n    const aliases = []\n    for (let i = 0; i < this._xobjects[alias].o.length; ++i) {\n      aliases.push(alias + '.' + i)\n    }\n    return aliases\n  }\n\n  async _startPage() {\n    if (this._currentPage) {\n      throw new Error('There is already a started page')\n    }\n\n    const page = this._currentPage = new PDF.Object('Page')\n    this._pages.push(page.toReference())\n\n    if (this._template) {\n      const taken = {}\n      for (const alias in this._template.colorSpaces) {\n        taken[alias] = null\n      }\n\n      let i = 1\n      for (1; ('/CS' + i) in taken; ++i) {}\n      this._currentColorSpace = '/CS' + i\n    } else {\n      this._currentColorSpace = '/CS1'\n    }\n\n    await this._startContentObject()\n\n    if (this._header) {\n      let chunk = ''\n      for (const i in this._header._objects) {\n        const obj = this._header._objects[i]\n        const alias = new PDF.Name(this._aliases.next('H'))\n        this._currentContent._xobjects[alias] = obj.toReference()\n        chunk += ops.Do(alias)\n      }\n\n      await this._write(chunk)\n      await this._header._render()\n    }\n\n    if (this._footer) {\n      let chunk = ''\n      for (const i in this._footer._objects) {\n        const obj = this._footer._objects[i]\n        const alias = new PDF.Name(this._aliases.next('F'))\n        this._currentContent._xobjects[alias] = obj.toReference()\n        chunk += ops.Do(alias)\n      }\n\n      await this._write(chunk)\n      await this._footer._render()\n    }\n\n    this._cursor.reset()\n\n    if (this._header) {\n      this._cursor.y -= this._header.height\n    }\n\n    if (this._footer) {\n      this._cursor.bottomOffset = this._footer.height\n    }\n  }\n\n  async _endPage() {\n    if (!this._currentPage) {\n      return\n    }\n\n    await this._endContentObject()\n\n    const fonts = new PDF.Dictionary({})\n    const xobjects = new PDF.Dictionary({})\n\n    for (const content of this._contents) {\n      for (const alias in content._fonts) {\n        fonts.add(alias, content._fonts[alias])\n      }\n\n      for (const alias in content._xobjects) {\n        xobjects.add(alias, content._xobjects[alias])\n      }\n    }\n\n    const page = this._currentPage\n    page.prop('Parent', this._pagesObj.toReference())\n\n    const colorSpace = new PDF.Dictionary({\n      [this._currentColorSpace]: new PDF.Array([new PDF.Name('ICCBased'), this._colorSpace.toReference()])\n    })\n    const resources = new PDF.Dictionary({\n      ColorSpace: colorSpace,\n      ProcSet: new PDF.Array([\n        new PDF.Name('PDF'),\n        new PDF.Name('Text'),\n        new PDF.Name('ImageB'),\n        new PDF.Name('ImageC'),\n        new PDF.Name('ImageI')\n      ]),\n      Font:    fonts,\n      XObject: xobjects,\n    })\n    page.prop('Resources', resources)\n\n    if (this._annotations.length > 0) {\n      page.prop('Annots', new PDF.Array(this._annotations))\n      this._annotations = []\n    }\n\n    const contents = this._contents.map(c => c._object.toReference())\n    page.prop('Contents', new PDF.Array(contents))\n\n    if (this._template) {\n      contents.unshift.apply(contents, this._template.contents)\n\n      for (const alias in this._template.colorSpaces) {\n        colorSpace.dictionary[alias] = this._template.colorSpaces[alias]\n      }\n\n      for (const alias in this._template.fonts) {\n        fonts.dictionary[alias] = this._template.fonts[alias]\n      }\n\n      for (const alias in this._template.xobjects) {\n        xobjects.dictionary[alias] = this._template.xobjects[alias]\n      }\n\n      const extGStates = new PDF.Dictionary({})\n      for (const alias in this._template.extGStates) {\n        extGStates.dictionary[alias] = this._template.extGStates[alias]\n      }\n      if (extGStates.length > 0) {\n        resources.set('ExtGState', extGStates)\n      }\n\n      const shadings = new PDF.Dictionary({})\n      for (const alias in this._template.shadings) {\n        shadings.dictionary[alias] = this._template.shadings[alias]\n      }\n      if (shadings.length > 0) {\n        resources.set('Shading', shadings)\n      }\n    }\n\n    await this._writeObject(page)\n\n    this._currentContent = this._currentPage = null\n    this._contents.length = 0\n\n    if (this._template && this._template.firstPageOnly) {\n      this._template = null\n    }\n  }\n\n  async _pageBreak(/* level */) {\n    if (!this._currentPage) {\n      await this._startPage()\n    }\n\n    await this._cursor.reset()\n\n    await this._endPage()\n    await this._startPage()\n  }\n\n  async _startContentObject(obj, force) {\n    // do not create new content object, if current content object is still empty\n    // 16 = /CS1 CS\n    //      /CS1 cs\n    if (!force && this._length - 16 == this._contentStart) {\n      return this._currentContent\n    }\n\n    if (this._currentContent) {\n      await this._endContentObject()\n    }\n\n    if (this._contentObjCreator) {\n      obj = this._contentObjCreator()\n    }\n\n    const content = this._currentContent = new ContentChunk(this, obj)\n    this._contents.push(content)\n\n    this._xref.add(content._object.id, {\n      offset: this._length,\n      obj:    content._object,\n    })\n\n    let chunk = content._object.id + ' ' + content._object.rev + ' obj\\n'\n      + content._object.properties.toString() + '\\n'\n      + 'stream\\n'\n\n    this._contentStart = this._length + chunk.length\n\n    // set color space\n    chunk += ops.CS(this._currentColorSpace) + ops.cs(this._currentColorSpace)\n    await this._write(chunk)\n\n    return content\n  }\n\n  async _endContentObject() {\n    if (!this._currentContent) {\n      return\n    }\n\n    this._currentContent._length.content = this._length - this._contentStart - 1\n    if (this._currentContent._length.content < 0) {\n      this._currentContent._length.content = 0\n    }\n\n    const chunk = 'endstream\\nendobj\\n\\n'\n    await this._write(chunk)\n    await this._writeObject(this._currentContent._length)\n\n    this._currentContent = null\n  }\n\n  _registerObject(object, force) {\n    if (object instanceof PDF.Stream) {\n      object = object.object\n    }\n\n    if (!force && object.id) {\n      return\n    }\n\n    object.id = this._nextObjectId\n    this._nextObjectId++\n  }\n\n  _writeObject(object) {\n    if (object instanceof PDF.Stream) {\n      object = object.object\n    }\n\n    if (!object.id) {\n      this._registerObject(object)\n    }\n\n    this._xref.add(object.id, {\n      offset: this._length,\n      obj:    object,\n    })\n    return this._write(object.toString() + '\\n\\n')\n  }\n\n  _updateOutlinesCount(id) {\n    if (this._outlines[id].data.count < 1) {\n      this._outlines[id].data.count -= 1\n      this._outlines[id].prop('Count', this._outlines[id].data.count)\n    } else {\n      this._outlines[id].data.count = -1\n      this._outlines[id].prop('Count', this._outlines[id].data.count)\n    }\n    const nextParent = this._outlines[id].data.parentIndex\n    if(nextParent !== undefined) {\n      this._updateOutlinesCount(nextParent)\n    }\n  }\n\n  // public API\n\n  async end() {\n\n    await Fragment.prototype.end.call(this);\n\n    await this._next()\n    await this._endPage()\n\n    for (const fn of this._finalize) {\n      await fn()\n    }\n\n    this._pagesObj.prop('MediaBox', new PDF.Array([0, 0, this.width, this.height]))\n    this._pagesObj.prop('Kids', this._pages)\n    this._pagesObj.prop('Count', this._pages.length)\n    await this._writeObject(this._pagesObj)\n    await this._writeObject(this._colorSpace)\n\n    for (const alias in this._fonts) {\n      const font = this._fonts[alias]\n      await font.f.write(this, font.o)\n    }\n\n    for (const alias in this._xobjects) {\n      const xobj = this._xobjects[alias]\n      await xobj.x.write(this, xobj.o)\n    }\n\n    const catalog = new PDF.Object('Catalog')\n    catalog.prop('Pages', this._pagesObj.toReference())\n    if (this._destinations.length > 0) {\n      const destsObj = new PDF.Object()\n      destsObj.prop(\"Dests\", this._destinations)\n      await this._writeObject(destsObj)\n      catalog.prop('Names', destsObj.toReference())\n    }\n    //Write outlines hierarchy if there are outlines\n    if(this._outlines.length > 0) {\n      for (let i = 0; i < this._outlines.length; i += 1) {\n        await this._writeObject(this._outlines[i])\n      }\n      catalog.prop('Outlines', this._outlines[0].toReference())\n    }\n    await this._writeObject(catalog)\n\n    // to support random access to individual objects, a PDF file\n    // contains a cross-reference table that can be used to locate\n    // and directly access pages and other important objects within the file\n    const startxref = this._length\n    await this._write(this._xref.toString())\n\n    // trailer\n    const objectsCount = this._nextObjectId - 1\n    const trailer = new PDF.Trailer(objectsCount + 1, catalog, this.info)\n    await this._write(trailer.toString() + '\\n')\n\n    // startxref\n    await this._write('startxref\\n' + startxref + '\\n%%EOF')\n\n    // close readable stream\n    this.push(null)\n  }\n\n  asBuffer(opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts\n      opts = undefined\n    }\n\n    const shouldEnd = !opts || opts.end !== false\n    let p = new Promise((resolve, reject) => {\n      const chunks = []\n      this.on('data', chunk => chunks.push(chunk))\n      this.on('end', () => resolve(Buffer.concat(chunks)))\n      this.on('error', reject)\n      if (shouldEnd) {\n        this.end()\n      }\n    })\n    if (typeof callback === 'function') {\n      p = p.then(data => callback(null, data)).catch(callback)\n    }\n    return p\n  }\n\n\n  header() {\n    const Header = require('./header')\n    const ctx = new Header(this, this)\n    this._begin(ctx)\n\n    this._pending.push(() => {\n      this._header = ctx\n      return ctx._start()\n    })\n\n    return ctx\n  }\n\n  footer() {\n    const Footer = require('./footer')\n    const ctx = new Footer(this, this)\n    this._begin(ctx)\n\n    this._pending.push(() => {\n      this._footer = ctx\n      return ctx._start()\n    })\n\n    return ctx\n  }\n\n  addPagesOf(external) {\n    if (!(external instanceof ExternalDocument)) {\n      throw new TypeError('argument must be of type ExternalDocument')\n    }\n\n    this._begin(null)\n    this._pending.push(() => external.write(this))\n  }\n\n  addPageOf(page, external) {\n    if (!(external instanceof ExternalDocument)) {\n      throw new TypeError('argument must be of type ExternalDocument')\n    }\n\n    if (!page || page < 1 || page > external.pageCount) {\n      throw new TypeError('ExternalDocument does not have page ' + page)\n    }\n\n    this._begin(null)\n    this._pending.push(() => external.write(this, page))\n  }\n\n  setTemplate(external, firstPageOnly = false) {\n    if (!(external instanceof ExternalDocument)) {\n      throw new TypeError('argument must be of type ExternalDocument')\n    }\n\n    this._begin(null)\n    this._pending.push(() => external.setAsTemplate(this, firstPageOnly))\n  }\n\n  outline(title, destination, parent) {\n    // Skip empty titles and/or destination\n    if (title === undefined || destination === undefined) return\n\n    // Create the root outline the first time this method is called\n    if (this._outlines.length === 0 ){\n      this._outlines[0] = new PDF.Object('Outlines')\n      this._outlines[0].data = {type: 'Outlines'}\n      this._registerObject(this._outlines[0])\n    }\n    // Find parent item\n    let parentIndex\n    if (typeof parent === 'number' && parent >= 0 && parent <= this._outlines.length) {\n      // the user provided a valid index number: use it as the parentIndex\n      parentIndex = parent\n    } else {\n      // the user did not provide a valid index number: search for it in the outline array\n      // if it is not found, create the corresponding parent at root level\n      if (parent === undefined || parent === '') {\n        parentIndex = 0\n      } else {\n        parentIndex = this._outlines.findIndex(\n          (item, index) => (item.data.title === parent)\n        )\n        if (parentIndex === -1) parentIndex = this.outline(parent, destination)\n      }\n    }\n\n    // Find siblings\n    let siblingsIndexes = this._outlines.reduce((result, item, index) => {\n      if (index !== 0 && item.data.parentIndex === parentIndex) result.push(index)\n      return result\n    }, [])\n\n    // Create item\n    const outline = new PDF.Object()\n    outline.data = {title, destination, parent}\n    outline.prop('Title', new PDF.String(title))\n    outline.prop('Parent', this._outlines[parentIndex].toReference())\n    outline.prop('A', new PDF.Dictionary({\n      S: 'GoTo',\n      D: new PDF.String(destination),\n    }))\n    this._registerObject(outline)\n    const outlineIndex = this._outlines.push(outline)-1\n\n    // Chain to siblings\n    const prevSiblingIndex = siblingsIndexes[siblingsIndexes.length-1]\n    if (prevSiblingIndex > 0) {\n      // Next\n      this._outlines[prevSiblingIndex].data.nextId = outlineIndex\n      this._outlines[prevSiblingIndex].prop('Next', this._outlines[outlineIndex].toReference())\n      // Prev\n      this._outlines[outlineIndex].data.prevId = prevSiblingIndex\n      this._outlines[outlineIndex].prop('Prev', this._outlines[prevSiblingIndex].toReference())\n    }\n\n    // Chain to parents\n    this._outlines[outlineIndex].data.parentIndex = parentIndex\n    if (siblingsIndexes.length === 0) {\n      // First\n      this._outlines[parentIndex].data.firstIndex = outlineIndex\n      this._outlines[parentIndex].prop('First', this._outlines[outlineIndex].toReference())\n    }\n    // Last\n    this._outlines[parentIndex].data.lastIndex = outlineIndex\n    this._outlines[parentIndex].prop('Last', this._outlines[outlineIndex].toReference())\n    // Count(s)\n    this._updateOutlinesCount(parentIndex)\n\n    return outlineIndex\n  }\n}\n\nObject.assign(Document.prototype, {\n    _begin: Fragment.prototype._begin,\n    _end: Fragment.prototype._end,\n    _opts: Fragment.prototype._opts,\n\n    text: Fragment.prototype.text,\n    cell: Fragment.prototype.cell,\n    table: Fragment.prototype.table,\n    image: Fragment.prototype.image,\n    pageBreak: Fragment.prototype.pageBreak,\n    op: Fragment.prototype.op,\n    destination: Fragment.prototype.destination,\n  })\n\nclass AliasGenerator {\n  constructor() {\n    this.nextId = {}\n    this.blocked = new Set()\n  }\n\n  next(prefix) {\n    if (!(prefix in this.nextId)) {\n      this.nextId[prefix] = 1\n    }\n\n    let next\n    do {\n      next = prefix + this.nextId[prefix]++\n    } while (this.blocked.has(next))\n\n    return next\n  }\n\n  block(alias) {\n    alias = String(alias)\n    if (alias[0] === '/') {\n      alias = alias.slice(1)\n    }\n\n    this.blocked.add(alias)\n  }\n\n  isBlocked(alias) {\n    alias = String(alias)\n    if (alias[0] === '/') {\n      alias = alias.slice(1)\n    }\n\n    return this.blocked.has(alias)\n  }\n\n  reset(prefix) {\n    this.nextId[prefix] = 1\n  }\n}\n\nmodule.exports = Document\n"]},"metadata":{},"sourceType":"script"}