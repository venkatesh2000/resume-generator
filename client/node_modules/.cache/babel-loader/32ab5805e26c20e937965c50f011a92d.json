{"ast":null,"code":"'use strict';\n\nconst UnicodeTrie = require('unicode-trie');\n\nconst ref = require('./classes');\n\nconst {\n  BK,\n  CR,\n  LF,\n  NL,\n  CB,\n  BA,\n  SP,\n  WJ,\n  AI,\n  AL,\n  SA,\n  SG,\n  XX,\n  CJ,\n  ID,\n  NS,\n  characterClasses\n} = require('./classes');\n\nconst {\n  DI_BRK,\n  IN_BRK,\n  CI_BRK,\n  CP_BRK,\n  PR_BRK,\n  pairTable\n} = require('./pairs');\n\nconst classTrie = new UnicodeTrie(hex2ab(require('./classes.json').buf));\n\nclass Break {\n  constructor(position, required) {\n    this.position = position;\n    this.required = required != null ? required : false;\n  }\n\n}\n\nmodule.exports = class LineBreaker {\n  constructor(string) {\n    this.string = string;\n    this.pos = 0;\n    this.lastPos = 0;\n    this.curClass = null;\n    this.nextClass = null;\n  }\n\n  nextCodePoint() {\n    const code = this.string.charCodeAt(this.pos++);\n    const next = this.string.charCodeAt(this.pos); // If a surrogate pair\n\n    if (0xd800 <= code && code <= 0xdbff && 0xdc00 <= next && next <= 0xdfff) {\n      this.pos++;\n      return (code - 0xd800) * 0x400 + (next - 0xdc00) + 0x10000;\n    }\n\n    return code;\n  }\n\n  nextCharClass(first) {\n    if (first == null) {\n      first = false;\n    }\n\n    return mapClass(classTrie.get(this.nextCodePoint()));\n  }\n\n  nextBreak() {\n    // get the first char if we're at the beginning of the string\n    if (this.curClass == null) {\n      this.curClass = mapFirst(this.nextCharClass());\n    }\n\n    while (this.pos < this.string.length) {\n      this.lastPos = this.pos;\n      const lastClass = this.nextClass;\n      this.nextClass = this.nextCharClass(); // explicit newline\n\n      if (this.curClass === BK || this.curClass === CR && this.nextClass !== LF) {\n        this.curClass = mapFirst(mapClass(this.nextClass));\n        return new Break(this.lastPos, true);\n      } // handle classes not handled by the pair table\n\n\n      let cur = null;\n\n      switch (this.nextClass) {\n        case SP:\n          cur = this.curClass;\n          break;\n\n        case BK:\n        case LF:\n        case NL:\n          cur = BK;\n          break;\n\n        case CR:\n          cur = CR;\n          break;\n\n        case CB:\n          cur = BA;\n          break;\n      }\n\n      if (cur != null) {\n        this.curClass = cur;\n\n        if (this.nextClass === CB) {\n          return new Break(this.lastPos);\n        }\n\n        continue;\n      } // if not handled already, use the pair table\n\n\n      let shouldBreak = false;\n\n      switch (pairTable[this.curClass][this.nextClass]) {\n        case DI_BRK:\n          // Direct break\n          shouldBreak = true;\n          break;\n\n        case IN_BRK:\n          // possible indirect break\n          shouldBreak = lastClass === SP;\n          break;\n\n        case CI_BRK:\n          // prohibited for combining marks\n          shouldBreak = lastClass === SP;\n\n          if (!shouldBreak) {\n            continue;\n          }\n\n          break;\n\n        case CP_BRK:\n          if (lastClass !== SP) {\n            continue;\n          }\n\n      }\n\n      this.curClass = this.nextClass;\n\n      if (shouldBreak) {\n        return new Break(this.lastPos);\n      }\n    }\n\n    if (this.pos >= this.string.length) {\n      if (this.lastPos < this.string.length) {\n        this.lastPos = this.string.length;\n        return new Break(this.string.length);\n      } else {\n        return null;\n      }\n    }\n  }\n\n};\n\nfunction mapClass(c) {\n  switch (c) {\n    case AI:\n      return AL;\n\n    case SA:\n    case SG:\n    case XX:\n      return AL;\n\n    case CJ:\n      return NS;\n\n    default:\n      return c;\n  }\n}\n\nfunction mapFirst(c) {\n  switch (c) {\n    case LF:\n    case NL:\n      return BK;\n\n    case CB:\n      return BA;\n\n    case SP:\n      return WJ;\n\n    default:\n      return c;\n  }\n}\n\nfunction hex2ab(hex) {\n  const view = new Uint8Array(hex.length / 2);\n\n  for (let i = 0; i < hex.length; i += 2) {\n    view[i / 2] = parseInt(hex.substring(i, i + 2), 16);\n  }\n\n  return view;\n}","map":{"version":3,"sources":["/mnt/c/Users/Venkatesh/Documents/6th Sem/Web Dev/project/resume-generator/node_modules/@rkusa/linebreak/src/linebreaker.js"],"names":["UnicodeTrie","require","ref","BK","CR","LF","NL","CB","BA","SP","WJ","AI","AL","SA","SG","XX","CJ","ID","NS","characterClasses","DI_BRK","IN_BRK","CI_BRK","CP_BRK","PR_BRK","pairTable","classTrie","hex2ab","buf","Break","constructor","position","required","module","exports","LineBreaker","string","pos","lastPos","curClass","nextClass","nextCodePoint","code","charCodeAt","next","nextCharClass","first","mapClass","get","nextBreak","mapFirst","length","lastClass","cur","shouldBreak","c","hex","view","Uint8Array","i","parseInt","substring"],"mappings":"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","sourcesContent":["'use strict'\n\nconst UnicodeTrie = require('unicode-trie')\nconst ref = require('./classes')\nconst { BK, CR, LF, NL, CB, BA, SP, WJ, AI, AL, SA, SG, XX, CJ, ID, NS, characterClasses} = require('./classes')\nconst { DI_BRK, IN_BRK, CI_BRK, CP_BRK, PR_BRK, pairTable } = require('./pairs')\n\nconst classTrie = new UnicodeTrie(hex2ab(require('./classes.json').buf))\n\nclass Break {\n  constructor(position, required) {\n    this.position = position\n    this.required = required != null ? required : false\n  }\n}\n\nmodule.exports = class LineBreaker {\n  constructor(string) {\n    this.string = string\n    this.pos = 0\n    this.lastPos = 0\n    this.curClass = null\n    this.nextClass = null\n  }\n\n  nextCodePoint() {\n    const code = this.string.charCodeAt(this.pos++)\n    const next = this.string.charCodeAt(this.pos)\n\n    // If a surrogate pair\n    if ((0xd800 <= code && code <= 0xdbff) && (0xdc00 <= next && next <= 0xdfff)) {\n      this.pos++\n      return ((code - 0xd800) * 0x400) + (next - 0xdc00) + 0x10000\n    }\n\n    return code\n  }\n\n  nextCharClass(first) {\n    if (first == null) {\n      first = false\n    }\n    return mapClass(classTrie.get(this.nextCodePoint()))\n  }\n\n  nextBreak() {\n    // get the first char if we're at the beginning of the string\n    if (this.curClass == null) {\n      this.curClass = mapFirst(this.nextCharClass())\n    }\n\n    while (this.pos < this.string.length) {\n      this.lastPos = this.pos\n      const lastClass = this.nextClass\n      this.nextClass = this.nextCharClass()\n\n      // explicit newline\n      if (this.curClass === BK || (this.curClass === CR && this.nextClass !== LF)) {\n        this.curClass = mapFirst(mapClass(this.nextClass))\n        return new Break(this.lastPos, true)\n      }\n\n      // handle classes not handled by the pair table\n      let cur = null\n      switch (this.nextClass) {\n        case SP:\n          cur = this.curClass\n          break\n        case BK:\n        case LF:\n        case NL:\n          cur = BK\n          break\n        case CR:\n          cur = CR\n          break\n        case CB:\n          cur = BA\n          break\n      }\n\n      if (cur != null) {\n        this.curClass = cur\n        if (this.nextClass === CB) {\n          return new Break(this.lastPos)\n        }\n        continue\n      }\n\n      // if not handled already, use the pair table\n      let shouldBreak = false\n      switch (pairTable[this.curClass][this.nextClass]) {\n        case DI_BRK: // Direct break\n          shouldBreak = true\n          break\n        case IN_BRK: // possible indirect break\n          shouldBreak = lastClass === SP\n          break\n        case CI_BRK: // prohibited for combining marks\n          shouldBreak = lastClass === SP\n          if (!shouldBreak) {\n            continue\n          }\n          break\n        case CP_BRK:\n          if (lastClass !== SP) {\n            continue\n          }\n      }\n\n      this.curClass = this.nextClass\n      if (shouldBreak) {\n        return new Break(this.lastPos)\n      }\n    }\n\n    if (this.pos >= this.string.length) {\n      if (this.lastPos < this.string.length) {\n        this.lastPos = this.string.length\n        return new Break(this.string.length)\n      } else {\n        return null\n      }\n    }\n  }\n}\n\nfunction mapClass(c) {\n  switch (c) {\n    case AI:\n      return AL\n    case SA:\n    case SG:\n    case XX:\n      return AL\n    case CJ:\n      return NS\n    default:\n      return c\n  }\n}\n\nfunction mapFirst(c) {\n  switch (c) {\n    case LF:\n    case NL:\n      return BK\n    case CB:\n      return BA\n    case SP:\n      return WJ\n    default:\n      return c\n  }\n}\n\nfunction hex2ab(hex) {\n  const view = new Uint8Array(hex.length / 2)\n\n  for (let i = 0; i < hex.length; i += 2) {\n    view[i / 2] = parseInt(hex.substring(i, i + 2), 16)\n  }\n\n  return view\n}\n"]},"metadata":{},"sourceType":"script"}