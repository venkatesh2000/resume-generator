{"ast":null,"code":"'use strict';\n\nconst version = require('../../package.json').version;\n\nconst PDFDictionary = require('./dictionary');\n\nconst PDFArray = require('./array');\n\nconst PDFString = require('./string');\n\nconst InfoKeys = {\n  title: 'Title',\n  author: 'Author',\n  subject: 'Subject',\n  keywords: 'Keywords',\n  creator: 'Creator',\n  producer: 'Producer',\n  creationDate: 'CreationDate',\n  modDate: 'ModDate'\n};\n\nclass PDFTrailer extends PDFDictionary {\n  constructor(size, root, info) {\n    super();\n    this.set('Size', size);\n    this.set('Root', root && root.toReference());\n    const id = new PDFString(info.id).toHexString();\n    this.set('ID', new PDFArray([id, id])); // Default to now and convert to string\n\n    info.creationDate = formatDate(info.creationDate || new Date());\n\n    if (!info.producer) {\n      // Set default producer if not one provided\n      info.producer = `pdfjs v${version} (github.com/rkusa/pdfjs)`;\n    }\n\n    if ('modDate' in info) {\n      // Convert to string\n      info.modDate = formatDate(info.modDate);\n    }\n\n    const infoDictionary = {};\n\n    for (const key in InfoKeys) {\n      if (key in info) {\n        infoDictionary[InfoKeys[key]] = new PDFString(info[key]);\n      }\n    }\n\n    this.set('Info', new PDFDictionary(infoDictionary));\n  }\n\n  toString() {\n    return 'trailer\\n' + PDFDictionary.prototype.toString.call(this);\n  }\n\n  static parse(xref, lexer) {\n    lexer.skipWhitespace(null, true);\n\n    if (lexer.readString(7) !== 'trailer') {\n      throw new Error('Invalid trailer: trailer expected but not found');\n    }\n\n    lexer.skipWhitespace(null, true);\n    const dict = PDFDictionary.parse(xref, lexer);\n    return dict;\n  }\n\n}\n\nmodule.exports = PDFTrailer;\n\nfunction formatDate(date) {\n  let str = 'D:' + date.getFullYear() + ('00' + (date.getMonth() + 1)).slice(-2) + ('00' + date.getDate()).slice(-2) + ('00' + date.getHours()).slice(-2) + ('00' + date.getMinutes()).slice(-2) + ('00' + date.getSeconds()).slice(-2);\n  let offset = date.getTimezoneOffset();\n  const rel = offset === 0 ? 'Z' : offset > 0 ? '-' : '+';\n  offset = Math.abs(offset);\n  const hoursOffset = Math.floor(offset / 60);\n  const minutesOffset = offset - hoursOffset * 60;\n  str += rel + ('00' + hoursOffset).slice(-2) + '\\'' + ('00' + minutesOffset).slice(-2) + '\\'';\n  return str;\n}","map":{"version":3,"sources":["/mnt/c/Users/Venkatesh/Documents/6th Sem/Web Dev/project/resume-generator/node_modules/pdfjs/lib/object/trailer.js"],"names":["version","require","PDFDictionary","PDFArray","PDFString","InfoKeys","title","author","subject","keywords","creator","producer","creationDate","modDate","PDFTrailer","constructor","size","root","info","set","toReference","id","toHexString","formatDate","Date","infoDictionary","key","toString","prototype","call","parse","xref","lexer","skipWhitespace","readString","Error","dict","module","exports","date","str","getFullYear","getMonth","slice","getDate","getHours","getMinutes","getSeconds","offset","getTimezoneOffset","rel","Math","abs","hoursOffset","floor","minutesOffset"],"mappings":"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","sourcesContent":["'use strict'\n\nconst version       = require('../../package.json').version\nconst PDFDictionary = require('./dictionary')\nconst PDFArray      = require('./array')\nconst PDFString     = require('./string')\n\nconst InfoKeys = {\n  title: 'Title',\n  author: 'Author',\n  subject: 'Subject',\n  keywords: 'Keywords',\n  creator: 'Creator',\n  producer: 'Producer',\n  creationDate: 'CreationDate',\n  modDate: 'ModDate'\n}\n\nclass PDFTrailer extends PDFDictionary {\n  constructor(size, root, info) {\n    super()\n\n    this.set('Size', size)\n    this.set('Root', root && root.toReference())\n\n    const id = (new PDFString(info.id)).toHexString()\n    this.set('ID', new PDFArray([id, id]))\n    \n    // Default to now and convert to string\n    info.creationDate = formatDate(info.creationDate || new Date)\n    if (!info.producer) {\n      // Set default producer if not one provided\n      info.producer = `pdfjs v${version} (github.com/rkusa/pdfjs)`\n    }\n    if ('modDate' in info) {\n    \t// Convert to string\n      info.modDate = formatDate(info.modDate)\n    }\n\n    const infoDictionary = {}\n\n    for (const key in InfoKeys) {\n      if (key in info) {\n        infoDictionary[InfoKeys[key]] = new PDFString(info[key])\n      }\n    }\n\n    this.set('Info', new PDFDictionary(infoDictionary))\n  }\n\n  toString() {\n    return 'trailer\\n' + PDFDictionary.prototype.toString.call(this)\n  }\n\n  static parse(xref, lexer) {\n    lexer.skipWhitespace(null, true)\n\n    if (lexer.readString(7) !== 'trailer') {\n      throw new Error('Invalid trailer: trailer expected but not found')\n    }\n\n    lexer.skipWhitespace(null, true)\n\n    const dict = PDFDictionary.parse(xref, lexer)\n    return dict\n  }\n}\n\nmodule.exports = PDFTrailer\n\nfunction formatDate(date) {\n  let str = 'D:'\n          + date.getFullYear()\n          + ('00' + (date.getMonth() + 1)).slice(-2)\n          + ('00' + date.getDate()).slice(-2)\n          + ('00' + date.getHours()).slice(-2)\n          + ('00' + date.getMinutes()).slice(-2)\n          + ('00' + date.getSeconds()).slice(-2)\n\n  let offset = date.getTimezoneOffset()\n  const rel = offset === 0 ? 'Z' : (offset > 0 ? '-' : '+')\n  offset = Math.abs(offset)\n  const hoursOffset = Math.floor(offset / 60)\n  const minutesOffset = offset - hoursOffset * 60\n\n  str += rel\n      + ('00' + hoursOffset).slice(-2)   + '\\''\n      + ('00' + minutesOffset).slice(-2) + '\\''\n\n  return str\n}\n"]},"metadata":{},"sourceType":"script"}