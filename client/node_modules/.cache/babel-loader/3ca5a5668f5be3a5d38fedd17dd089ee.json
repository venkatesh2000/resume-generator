{"ast":null,"code":"'use strict';\n\nconst Fragment = require('./fragment');\n\nconst util = require('./util');\n\nconst ops = require('./ops');\n\nconst PDF = require('./object');\n\nmodule.exports = class Header extends Fragment {\n  constructor(doc, parent) {\n    super(doc, parent); // a header could consist out of multiple FormXObjects and this property is later used keep\n    // track of them\n\n    this._objects = []; // this array keeps track of all page numbers rendered in the header, because their rendering\n    // is postponed\n\n    this._pageNumbers = []; // create new cursor for header context to not inherite bottom offset of document, which the\n    // document receives from having a header\n\n    this._cursor = this._cursor.clone();\n  } /// private API\n  // prevent page breaks inside a header\n\n\n  async _pageBreak(level) {\n    throw new Error('Header is to long (tried to execute a page break inside the header)');\n  }\n\n  async _start() {\n    // changing the header will force ending and starting with a new page\n    await this._doc._endPage();\n    await this._setup();\n  }\n\n  async _setup() {\n    this._cursor.reset(); // these objects will be written to the document after all FormXObjects are written\n    // it is therefore necessary to keep track of them seperately\n\n\n    this._resources = new PDF.Object();\n\n    this._doc._registerObject(this._resources);\n\n    this._bbox = new PDF.Object();\n\n    this._doc._registerObject(this._bbox); // a FormXObject will receive a Resources dictionary similar to Page objects, which is\n    // why it is necessary to keep track of used fonts and xobjects\n\n\n    this.fonts = new PDF.Dictionary({});\n    this.xobjects = new PDF.Dictionary({}); // this header object has a similar interface like the page object and it is used as such\n    // until the header has finished rendering (necessary to track the used fonts and xobjects)\n\n    this._doc._contentObjCreator = this._createObject.bind(this); // close current content object and start a new one (by setting the _contentObjCreator object\n    // above, the new content object will be created by calling the header's _createObject\n    // method)\n\n    await this._doc._startContentObject();\n  }\n\n  _createObject() {\n    // this is going to be called on each _startContentObject() call as long as the header\n    // is rendered, which creates a FormXObject (instead of the usual plain object)\n    const xobj = new PDF.Object('XObject');\n    xobj.prop('Subtype', 'Form');\n    xobj.prop('FormType', 1);\n    xobj.prop('BBox', this._bbox.toReference());\n    xobj.prop('Resources', this._resources.toReference());\n    return xobj;\n  } // while most parts of the header is static (i.e. rendered only once and then reused), there are\n  // some dynamic parts (e.g. page numbers) which are rendered on each page\n  // these parts are rendered here\n\n\n  async _render() {\n    if (this._pageNumbers.length === 0) {\n      return;\n    } // lazy load text, because of cyclic dependencies of Fragment\n\n\n    const Text = require('./text');\n\n    for (const instance of this._pageNumbers) {\n      let withPageCount = false;\n\n      if (instance.fn) {\n        const lhs = instance.fn(1, 1);\n        const rhs = instance.fn(1, 10);\n        withPageCount = lhs.length !== rhs.length;\n      } // postpone writing page number until the end of the document, because the total page count\n      // is not known now\n\n\n      if (withPageCount) {\n        // since there is only text with an already known font, the fonts dictionary can already\n        // be build\n        const fonts = new PDF.Dictionary({});\n\n        const font = this._doc._fontInstance(instance.opts.font || this._doc.defaultFont);\n\n        const fontAlias = this._doc._fontAlias(font);\n\n        fonts.set(fontAlias, this._doc._fonts[fontAlias].o.toReference()); // create the FormXObject that is used to render the page numbers\n\n        const xobj = new PDF.Object('XObject');\n        xobj.prop('Subtype', 'Form');\n        xobj.prop('FormType', 1);\n        xobj.prop('BBox', new PDF.Array([instance.x, instance.y, instance.x + instance.width, instance.y - instance.height]));\n        xobj.prop('Resources', new PDF.Dictionary({\n          ColorSpace: new PDF.Dictionary({\n            CS1: new PDF.Array([new PDF.Name('ICCBased'), this._doc._colorSpace.toReference()])\n          }),\n          ProcSet: new PDF.Array([new PDF.Name('Text')]),\n          Font: fonts\n        }));\n\n        this._doc._registerObject(xobj); // calculate the number of the currently rendered page\n\n\n        const currentPage = this._doc._pages.length; // add a handler to the document that will be called when the document is finished up\n        // this is necessary because the total count of pages is not yet known\n\n        this._doc._finalize.push(async () => {\n          await this._doc._startContentObject(xobj); // setup the cursor to the position the page numbers should be rendered at\n\n          this._cursor.y = instance.y;\n          this._cursor.x = instance.x;\n          this._cursor.width = instance.width; // negate document bottomOffset, which is there because of this header\n\n          this._cursor.bottomOffset = -this._doc._cursor.bottomOffset; // create the text representing the page numbers\n\n          const pageCount = this._doc._pages.length;\n          const str = instance.fn ? instance.fn(currentPage, pageCount) : currentPage; // manually render the text\n\n          const txt = new Text(this._doc, this, instance.opts);\n          txt._parts++;\n          txt._ended = true;\n          await txt._start();\n          await txt._render(str, instance.opts);\n          await txt._end();\n          await this._doc._endContentObject();\n        }); // render and register the FormXObject to the current page\n\n\n        const alias = new PDF.Name(this._doc._aliases.next('X'));\n        this._doc._currentContent._xobjects[alias] = xobj.toReference();\n        await this._doc._write(ops.Do(alias));\n      } else {\n        // if there is now total page count necessary, we can write the current page number directly\n        this._cursor.y = instance.y;\n        this._cursor.x = instance.x;\n        this._cursor.width = instance.width; // negate document bottomOffset, which is there because of this header\n\n        this._cursor.bottomOffset = -this._doc._cursor.bottomOffset;\n        const txt = new Text(this._doc, this, instance.opts);\n        txt._parts++;\n        txt._ended = true;\n        await txt._start();\n        await txt._render(String(this._doc._pages.length), instance.opts);\n        await txt._end();\n      }\n    }\n  }\n\n  async _end() {\n    // save the height of the header\n    // this is used to correctly offset the cursor when rendering the page\n    this.height = this._doc._cursor.startY - this._doc._cursor.y;\n    await this._doc._endContentObject(); // collect all fonts and xobjects that are used in the header\n\n    for (const content of this._doc._contents) {\n      for (const alias in content._fonts) {\n        this.fonts.add(alias, content._fonts[alias]);\n      }\n\n      for (const alias in content._xobjects) {\n        this.xobjects.add(alias, content._xobjects[alias]);\n      }\n    } // create the Resources object for the header's FormXObjects\n\n\n    this._resources.content = new PDF.Dictionary({\n      ColorSpace: new PDF.Dictionary({\n        CS1: new PDF.Array([new PDF.Name('ICCBased'), this._doc._colorSpace.toReference()])\n      }),\n      ProcSet: new PDF.Array([new PDF.Name('PDF'), new PDF.Name('Text'), new PDF.Name('ImageB'), new PDF.Name('ImageC'), new PDF.Name('ImageI')]),\n      Font: this.fonts,\n      XObject: this.xobjects\n    });\n    await this._doc._writeObject(this._resources); // setup the BBox\n\n    this._bbox.content = new PDF.Array([this._cursor.startX, this._cursor.startY, this._cursor.startX + this._doc._cursor.width, this._doc._cursor.y]);\n    await this._doc._writeObject(this._bbox); // the header can consist out of multiple FormXObjects, which are collected here\n\n    this._objects = this._doc._contents.map(c => c._object); // reset everything\n\n    this._doc._cursor.reset();\n\n    this._doc._currentContent = null;\n    this._doc._contents.length = 0;\n    this._doc._contentObjCreator = null;\n    this._cursor.y -= this.height;\n  } /// public API\n\n\n  pageNumber(fn, opts) {\n    if (typeof fn === 'object') {\n      opts = fn;\n      fn = undefined;\n    }\n\n    if (!opts || typeof opts !== 'object') {\n      opts = {};\n    }\n\n    const font = this._doc._fontInstance(opts.font || this._doc.defaultFont);\n\n    const fontSize = opts.fontSize || this._doc.defaultFontSize;\n    const lineHeight = opts.lineHeight || this._doc.defaultLineHeight;\n    const height = font.lineHeight(fontSize, true) * lineHeight;\n    const descent = -font.descent(fontSize) * lineHeight;\n\n    this._begin(null);\n\n    this._pending.push(() => {\n      this._pageNumbers.push({\n        y: this._cursor.y,\n        x: this._cursor.x,\n        width: this._cursor.width,\n        height: height + descent,\n        opts: opts,\n        fn: fn\n      });\n\n      this._cursor.y -= height + descent;\n      return Promise.resolve();\n    });\n  }\n\n};","map":{"version":3,"sources":["/mnt/c/Users/Venkatesh/Documents/6th Sem/Web Dev/project/resume-generator/node_modules/pdfjs/lib/header.js"],"names":["Fragment","require","util","ops","PDF","module","exports","Header","constructor","doc","parent","_objects","_pageNumbers","_cursor","clone","_pageBreak","level","Error","_start","_doc","_endPage","_setup","reset","_resources","Object","_registerObject","_bbox","fonts","Dictionary","xobjects","_contentObjCreator","_createObject","bind","_startContentObject","xobj","prop","toReference","_render","length","Text","instance","withPageCount","fn","lhs","rhs","font","_fontInstance","opts","defaultFont","fontAlias","_fontAlias","set","_fonts","o","Array","x","y","width","height","ColorSpace","CS1","Name","_colorSpace","ProcSet","Font","currentPage","_pages","_finalize","push","bottomOffset","pageCount","str","txt","_parts","_ended","_end","_endContentObject","alias","_aliases","next","_currentContent","_xobjects","_write","Do","String","startY","content","_contents","add","XObject","_writeObject","startX","map","c","_object","pageNumber","undefined","fontSize","defaultFontSize","lineHeight","defaultLineHeight","descent","_begin","_pending","Promise","resolve"],"mappings":"AAAA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,QAAD,CAApB;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAMG,GAAG,GAAGH,OAAO,CAAC,UAAD,CAAnB;;AAEAI,MAAM,CAACC,OAAP,GAAiB,MAAMC,MAAN,SAAqBP,QAArB,CAA8B;AAC7CQ,EAAAA,WAAW,CAACC,GAAD,EAAMC,MAAN,EAAc;AACvB,UAAMD,GAAN,EAAWC,MAAX,EADuB,CAGvB;AACA;;AACA,SAAKC,QAAL,GAAgB,EAAhB,CALuB,CAOvB;AACA;;AACA,SAAKC,YAAL,GAAoB,EAApB,CATuB,CAWvB;AACA;;AACA,SAAKC,OAAL,GAAe,KAAKA,OAAL,CAAaC,KAAb,EAAf;AACD,GAf4C,CAiB7C;AAEA;;;AACgB,QAAVC,UAAU,CAACC,KAAD,EAAQ;AACtB,UAAM,IAAIC,KAAJ,CAAU,qEAAV,CAAN;AACD;;AAEW,QAANC,MAAM,GAAG;AACb;AACA,UAAM,KAAKC,IAAL,CAAUC,QAAV,EAAN;AAEA,UAAM,KAAKC,MAAL,EAAN;AACD;;AAEW,QAANA,MAAM,GAAG;AACb,SAAKR,OAAL,CAAaS,KAAb,GADa,CAGb;AACA;;;AACA,SAAKC,UAAL,GAAkB,IAAInB,GAAG,CAACoB,MAAR,EAAlB;;AACA,SAAKL,IAAL,CAAUM,eAAV,CAA0B,KAAKF,UAA/B;;AACA,SAAKG,KAAL,GAAa,IAAItB,GAAG,CAACoB,MAAR,EAAb;;AACA,SAAKL,IAAL,CAAUM,eAAV,CAA0B,KAAKC,KAA/B,EARa,CAUb;AACA;;;AACA,SAAKC,KAAL,GAAgB,IAAIvB,GAAG,CAACwB,UAAR,CAAmB,EAAnB,CAAhB;AACA,SAAKC,QAAL,GAAgB,IAAIzB,GAAG,CAACwB,UAAR,CAAmB,EAAnB,CAAhB,CAba,CAeb;AACA;;AACA,SAAKT,IAAL,CAAUW,kBAAV,GAA+B,KAAKC,aAAL,CAAmBC,IAAnB,CAAwB,IAAxB,CAA/B,CAjBa,CAmBb;AACA;AACA;;AACA,UAAM,KAAKb,IAAL,CAAUc,mBAAV,EAAN;AACD;;AAEDF,EAAAA,aAAa,GAAG;AACd;AACA;AACA,UAAMG,IAAI,GAAG,IAAI9B,GAAG,CAACoB,MAAR,CAAe,SAAf,CAAb;AACAU,IAAAA,IAAI,CAACC,IAAL,CAAU,SAAV,EAAqB,MAArB;AACAD,IAAAA,IAAI,CAACC,IAAL,CAAU,UAAV,EAAsB,CAAtB;AACAD,IAAAA,IAAI,CAACC,IAAL,CAAU,MAAV,EAAkB,KAAKT,KAAL,CAAWU,WAAX,EAAlB;AACAF,IAAAA,IAAI,CAACC,IAAL,CAAU,WAAV,EAAuB,KAAKZ,UAAL,CAAgBa,WAAhB,EAAvB;AACA,WAAOF,IAAP;AACD,GAjE4C,CAmE7C;AACA;AACA;;;AACa,QAAPG,OAAO,GAAG;AACd,QAAI,KAAKzB,YAAL,CAAkB0B,MAAlB,KAA6B,CAAjC,EAAoC;AAClC;AACD,KAHa,CAKd;;;AACA,UAAMC,IAAI,GAAGtC,OAAO,CAAC,QAAD,CAApB;;AAEA,SAAK,MAAMuC,QAAX,IAAuB,KAAK5B,YAA5B,EAA0C;AACxC,UAAI6B,aAAa,GAAG,KAApB;;AACA,UAAID,QAAQ,CAACE,EAAb,EAAiB;AACf,cAAMC,GAAG,GAAGH,QAAQ,CAACE,EAAT,CAAY,CAAZ,EAAe,CAAf,CAAZ;AACA,cAAME,GAAG,GAAGJ,QAAQ,CAACE,EAAT,CAAY,CAAZ,EAAe,EAAf,CAAZ;AACAD,QAAAA,aAAa,GAAGE,GAAG,CAACL,MAAJ,KAAeM,GAAG,CAACN,MAAnC;AACD,OANuC,CAQxC;AACA;;;AACA,UAAIG,aAAJ,EAAmB;AACjB;AACA;AACA,cAAMd,KAAK,GAAG,IAAIvB,GAAG,CAACwB,UAAR,CAAmB,EAAnB,CAAd;;AACA,cAAMiB,IAAI,GAAG,KAAK1B,IAAL,CAAU2B,aAAV,CAAwBN,QAAQ,CAACO,IAAT,CAAcF,IAAd,IAAsB,KAAK1B,IAAL,CAAU6B,WAAxD,CAAb;;AACA,cAAMC,SAAS,GAAG,KAAK9B,IAAL,CAAU+B,UAAV,CAAqBL,IAArB,CAAlB;;AACAlB,QAAAA,KAAK,CAACwB,GAAN,CAAUF,SAAV,EAAqB,KAAK9B,IAAL,CAAUiC,MAAV,CAAiBH,SAAjB,EAA4BI,CAA5B,CAA8BjB,WAA9B,EAArB,EANiB,CAQjB;;AACA,cAAMF,IAAI,GAAG,IAAI9B,GAAG,CAACoB,MAAR,CAAe,SAAf,CAAb;AACAU,QAAAA,IAAI,CAACC,IAAL,CAAU,SAAV,EAAqB,MAArB;AACAD,QAAAA,IAAI,CAACC,IAAL,CAAU,UAAV,EAAsB,CAAtB;AACAD,QAAAA,IAAI,CAACC,IAAL,CAAU,MAAV,EAAkB,IAAI/B,GAAG,CAACkD,KAAR,CAAc,CAACd,QAAQ,CAACe,CAAV,EAAaf,QAAQ,CAACgB,CAAtB,EAAyBhB,QAAQ,CAACe,CAAT,GAAaf,QAAQ,CAACiB,KAA/C,EAAsDjB,QAAQ,CAACgB,CAAT,GAAahB,QAAQ,CAACkB,MAA5E,CAAd,CAAlB;AACAxB,QAAAA,IAAI,CAACC,IAAL,CAAU,WAAV,EAAuB,IAAI/B,GAAG,CAACwB,UAAR,CAAmB;AACxC+B,UAAAA,UAAU,EAAE,IAAIvD,GAAG,CAACwB,UAAR,CAAmB;AAC7BgC,YAAAA,GAAG,EAAE,IAAIxD,GAAG,CAACkD,KAAR,CAAc,CAAC,IAAIlD,GAAG,CAACyD,IAAR,CAAa,UAAb,CAAD,EAA2B,KAAK1C,IAAL,CAAU2C,WAAV,CAAsB1B,WAAtB,EAA3B,CAAd;AADwB,WAAnB,CAD4B;AAIxC2B,UAAAA,OAAO,EAAE,IAAI3D,GAAG,CAACkD,KAAR,CAAc,CAAC,IAAIlD,GAAG,CAACyD,IAAR,CAAa,MAAb,CAAD,CAAd,CAJ+B;AAKxCG,UAAAA,IAAI,EAAKrC;AAL+B,SAAnB,CAAvB;;AAOA,aAAKR,IAAL,CAAUM,eAAV,CAA0BS,IAA1B,EApBiB,CAsBjB;;;AACA,cAAM+B,WAAW,GAAG,KAAK9C,IAAL,CAAU+C,MAAV,CAAiB5B,MAArC,CAvBiB,CAyBjB;AACA;;AACA,aAAKnB,IAAL,CAAUgD,SAAV,CAAoBC,IAApB,CAAyB,YAAY;AACnC,gBAAM,KAAKjD,IAAL,CAAUc,mBAAV,CAA8BC,IAA9B,CAAN,CADmC,CAGnC;;AACA,eAAKrB,OAAL,CAAa2C,CAAb,GAAiBhB,QAAQ,CAACgB,CAA1B;AACA,eAAK3C,OAAL,CAAa0C,CAAb,GAAiBf,QAAQ,CAACe,CAA1B;AACA,eAAK1C,OAAL,CAAa4C,KAAb,GAAqBjB,QAAQ,CAACiB,KAA9B,CANmC,CAQnC;;AACA,eAAK5C,OAAL,CAAawD,YAAb,GAA4B,CAAC,KAAKlD,IAAL,CAAUN,OAAV,CAAkBwD,YAA/C,CATmC,CAWnC;;AACA,gBAAMC,SAAS,GAAI,KAAKnD,IAAL,CAAU+C,MAAV,CAAiB5B,MAApC;AACA,gBAAMiC,GAAG,GAAG/B,QAAQ,CAACE,EAAT,GAAcF,QAAQ,CAACE,EAAT,CAAYuB,WAAZ,EAAyBK,SAAzB,CAAd,GAAoDL,WAAhE,CAbmC,CAenC;;AACA,gBAAMO,GAAG,GAAG,IAAIjC,IAAJ,CAAS,KAAKpB,IAAd,EAAoB,IAApB,EAA0BqB,QAAQ,CAACO,IAAnC,CAAZ;AACAyB,UAAAA,GAAG,CAACC,MAAJ;AACAD,UAAAA,GAAG,CAACE,MAAJ,GAAa,IAAb;AACA,gBAAMF,GAAG,CAACtD,MAAJ,EAAN;AACA,gBAAMsD,GAAG,CAACnC,OAAJ,CAAYkC,GAAZ,EAAiB/B,QAAQ,CAACO,IAA1B,CAAN;AACA,gBAAMyB,GAAG,CAACG,IAAJ,EAAN;AAEA,gBAAM,KAAKxD,IAAL,CAAUyD,iBAAV,EAAN;AACD,SAxBD,EA3BiB,CAqDjB;;;AACA,cAAMC,KAAK,GAAG,IAAIzE,GAAG,CAACyD,IAAR,CAAa,KAAK1C,IAAL,CAAU2D,QAAV,CAAmBC,IAAnB,CAAwB,GAAxB,CAAb,CAAd;AACA,aAAK5D,IAAL,CAAU6D,eAAV,CAA0BC,SAA1B,CAAoCJ,KAApC,IAA6C3C,IAAI,CAACE,WAAL,EAA7C;AACA,cAAM,KAAKjB,IAAL,CAAU+D,MAAV,CAAiB/E,GAAG,CAACgF,EAAJ,CAAON,KAAP,CAAjB,CAAN;AACD,OAzDD,MAyDO;AACL;AACA,aAAKhE,OAAL,CAAa2C,CAAb,GAAiBhB,QAAQ,CAACgB,CAA1B;AACA,aAAK3C,OAAL,CAAa0C,CAAb,GAAiBf,QAAQ,CAACe,CAA1B;AACA,aAAK1C,OAAL,CAAa4C,KAAb,GAAqBjB,QAAQ,CAACiB,KAA9B,CAJK,CAML;;AACA,aAAK5C,OAAL,CAAawD,YAAb,GAA4B,CAAC,KAAKlD,IAAL,CAAUN,OAAV,CAAkBwD,YAA/C;AAEA,cAAMG,GAAG,GAAG,IAAIjC,IAAJ,CAAS,KAAKpB,IAAd,EAAoB,IAApB,EAA0BqB,QAAQ,CAACO,IAAnC,CAAZ;AACAyB,QAAAA,GAAG,CAACC,MAAJ;AACAD,QAAAA,GAAG,CAACE,MAAJ,GAAa,IAAb;AACA,cAAMF,GAAG,CAACtD,MAAJ,EAAN;AACA,cAAMsD,GAAG,CAACnC,OAAJ,CAAY+C,MAAM,CAAC,KAAKjE,IAAL,CAAU+C,MAAV,CAAiB5B,MAAlB,CAAlB,EAA6CE,QAAQ,CAACO,IAAtD,CAAN;AACA,cAAMyB,GAAG,CAACG,IAAJ,EAAN;AACD;AACF;AACF;;AAES,QAAJA,IAAI,GAAG;AACX;AACA;AACA,SAAKjB,MAAL,GAAc,KAAKvC,IAAL,CAAUN,OAAV,CAAkBwE,MAAlB,GAA2B,KAAKlE,IAAL,CAAUN,OAAV,CAAkB2C,CAA3D;AAEA,UAAM,KAAKrC,IAAL,CAAUyD,iBAAV,EAAN,CALW,CAOX;;AACA,SAAK,MAAMU,OAAX,IAAsB,KAAKnE,IAAL,CAAUoE,SAAhC,EAA2C;AACzC,WAAK,MAAMV,KAAX,IAAoBS,OAAO,CAAClC,MAA5B,EAAoC;AAClC,aAAKzB,KAAL,CAAW6D,GAAX,CAAeX,KAAf,EAAsBS,OAAO,CAAClC,MAAR,CAAeyB,KAAf,CAAtB;AACD;;AAED,WAAK,MAAMA,KAAX,IAAoBS,OAAO,CAACL,SAA5B,EAAuC;AACrC,aAAKpD,QAAL,CAAc2D,GAAd,CAAkBX,KAAlB,EAAyBS,OAAO,CAACL,SAAR,CAAkBJ,KAAlB,CAAzB;AACD;AACF,KAhBU,CAkBX;;;AACA,SAAKtD,UAAL,CAAgB+D,OAAhB,GAA0B,IAAIlF,GAAG,CAACwB,UAAR,CAAmB;AAC3C+B,MAAAA,UAAU,EAAE,IAAIvD,GAAG,CAACwB,UAAR,CAAmB;AAC7BgC,QAAAA,GAAG,EAAE,IAAIxD,GAAG,CAACkD,KAAR,CAAc,CAAC,IAAIlD,GAAG,CAACyD,IAAR,CAAa,UAAb,CAAD,EAA2B,KAAK1C,IAAL,CAAU2C,WAAV,CAAsB1B,WAAtB,EAA3B,CAAd;AADwB,OAAnB,CAD+B;AAI3C2B,MAAAA,OAAO,EAAE,IAAI3D,GAAG,CAACkD,KAAR,CAAc,CACrB,IAAIlD,GAAG,CAACyD,IAAR,CAAa,KAAb,CADqB,EAErB,IAAIzD,GAAG,CAACyD,IAAR,CAAa,MAAb,CAFqB,EAGrB,IAAIzD,GAAG,CAACyD,IAAR,CAAa,QAAb,CAHqB,EAIrB,IAAIzD,GAAG,CAACyD,IAAR,CAAa,QAAb,CAJqB,EAKrB,IAAIzD,GAAG,CAACyD,IAAR,CAAa,QAAb,CALqB,CAAd,CAJkC;AAW3CG,MAAAA,IAAI,EAAK,KAAKrC,KAX6B;AAY3C8D,MAAAA,OAAO,EAAE,KAAK5D;AAZ6B,KAAnB,CAA1B;AAcA,UAAM,KAAKV,IAAL,CAAUuE,YAAV,CAAuB,KAAKnE,UAA5B,CAAN,CAjCW,CAmCX;;AACA,SAAKG,KAAL,CAAW4D,OAAX,GAAqB,IAAIlF,GAAG,CAACkD,KAAR,CAAc,CACjC,KAAKzC,OAAL,CAAa8E,MADoB,EACZ,KAAK9E,OAAL,CAAawE,MADD,EAEjC,KAAKxE,OAAL,CAAa8E,MAAb,GAAsB,KAAKxE,IAAL,CAAUN,OAAV,CAAkB4C,KAFP,EAEc,KAAKtC,IAAL,CAAUN,OAAV,CAAkB2C,CAFhC,CAAd,CAArB;AAIA,UAAM,KAAKrC,IAAL,CAAUuE,YAAV,CAAuB,KAAKhE,KAA5B,CAAN,CAxCW,CA0CX;;AACA,SAAKf,QAAL,GAAgB,KAAKQ,IAAL,CAAUoE,SAAV,CAAoBK,GAApB,CAAwBC,CAAC,IAAIA,CAAC,CAACC,OAA/B,CAAhB,CA3CW,CA6CX;;AACA,SAAK3E,IAAL,CAAUN,OAAV,CAAkBS,KAAlB;;AAEA,SAAKH,IAAL,CAAU6D,eAAV,GAA4B,IAA5B;AACA,SAAK7D,IAAL,CAAUoE,SAAV,CAAoBjD,MAApB,GAA6B,CAA7B;AAEA,SAAKnB,IAAL,CAAUW,kBAAV,GAA+B,IAA/B;AAEA,SAAKjB,OAAL,CAAa2C,CAAb,IAAkB,KAAKE,MAAvB;AACD,GA1N4C,CA4N7C;;;AAEAqC,EAAAA,UAAU,CAACrD,EAAD,EAAKK,IAAL,EAAW;AACnB,QAAI,OAAOL,EAAP,KAAc,QAAlB,EAA4B;AAC1BK,MAAAA,IAAI,GAAGL,EAAP;AACAA,MAAAA,EAAE,GAAGsD,SAAL;AACD;;AAED,QAAI,CAACjD,IAAD,IAAS,OAAOA,IAAP,KAAgB,QAA7B,EAAuC;AACrCA,MAAAA,IAAI,GAAG,EAAP;AACD;;AAED,UAAMF,IAAI,GAAG,KAAK1B,IAAL,CAAU2B,aAAV,CAAwBC,IAAI,CAACF,IAAL,IAAa,KAAK1B,IAAL,CAAU6B,WAA/C,CAAb;;AACA,UAAMiD,QAAQ,GAAGlD,IAAI,CAACkD,QAAL,IAAiB,KAAK9E,IAAL,CAAU+E,eAA5C;AACA,UAAMC,UAAU,GAAGpD,IAAI,CAACoD,UAAL,IAAmB,KAAKhF,IAAL,CAAUiF,iBAAhD;AAEA,UAAM1C,MAAM,GAAGb,IAAI,CAACsD,UAAL,CAAgBF,QAAhB,EAA0B,IAA1B,IAAkCE,UAAjD;AACA,UAAME,OAAO,GAAG,CAACxD,IAAI,CAACwD,OAAL,CAAaJ,QAAb,CAAD,GAA0BE,UAA1C;;AAEA,SAAKG,MAAL,CAAY,IAAZ;;AACA,SAAKC,QAAL,CAAcnC,IAAd,CAAmB,MAAM;AACvB,WAAKxD,YAAL,CAAkBwD,IAAlB,CAAuB;AACrBZ,QAAAA,CAAC,EAAE,KAAK3C,OAAL,CAAa2C,CADK;AAErBD,QAAAA,CAAC,EAAE,KAAK1C,OAAL,CAAa0C,CAFK;AAGrBE,QAAAA,KAAK,EAAE,KAAK5C,OAAL,CAAa4C,KAHC;AAIrBC,QAAAA,MAAM,EAAEA,MAAM,GAAG2C,OAJI;AAKrBtD,QAAAA,IAAI,EAAEA,IALe;AAMrBL,QAAAA,EAAE,EAAEA;AANiB,OAAvB;;AASA,WAAK7B,OAAL,CAAa2C,CAAb,IAAkBE,MAAM,GAAG2C,OAA3B;AACA,aAAOG,OAAO,CAACC,OAAR,EAAP;AACD,KAZD;AAaD;;AA7P4C,CAA/C","sourcesContent":["'use strict'\n\nconst Fragment = require('./fragment')\nconst util = require('./util')\nconst ops = require('./ops')\nconst PDF = require('./object')\n\nmodule.exports = class Header extends Fragment {\n  constructor(doc, parent) {\n    super(doc, parent)\n\n    // a header could consist out of multiple FormXObjects and this property is later used keep\n    // track of them\n    this._objects = []\n\n    // this array keeps track of all page numbers rendered in the header, because their rendering\n    // is postponed\n    this._pageNumbers = []\n\n    // create new cursor for header context to not inherite bottom offset of document, which the\n    // document receives from having a header\n    this._cursor = this._cursor.clone()\n  }\n\n  /// private API\n\n  // prevent page breaks inside a header\n  async _pageBreak(level) {\n    throw new Error('Header is to long (tried to execute a page break inside the header)')\n  }\n\n  async _start() {\n    // changing the header will force ending and starting with a new page\n    await this._doc._endPage()\n\n    await this._setup()\n  }\n\n  async _setup() {\n    this._cursor.reset()\n\n    // these objects will be written to the document after all FormXObjects are written\n    // it is therefore necessary to keep track of them seperately\n    this._resources = new PDF.Object()\n    this._doc._registerObject(this._resources)\n    this._bbox = new PDF.Object()\n    this._doc._registerObject(this._bbox)\n\n    // a FormXObject will receive a Resources dictionary similar to Page objects, which is\n    // why it is necessary to keep track of used fonts and xobjects\n    this.fonts    = new PDF.Dictionary({})\n    this.xobjects = new PDF.Dictionary({})\n\n    // this header object has a similar interface like the page object and it is used as such\n    // until the header has finished rendering (necessary to track the used fonts and xobjects)\n    this._doc._contentObjCreator = this._createObject.bind(this)\n\n    // close current content object and start a new one (by setting the _contentObjCreator object\n    // above, the new content object will be created by calling the header's _createObject\n    // method)\n    await this._doc._startContentObject()\n  }\n\n  _createObject() {\n    // this is going to be called on each _startContentObject() call as long as the header\n    // is rendered, which creates a FormXObject (instead of the usual plain object)\n    const xobj = new PDF.Object('XObject')\n    xobj.prop('Subtype', 'Form')\n    xobj.prop('FormType', 1)\n    xobj.prop('BBox', this._bbox.toReference())\n    xobj.prop('Resources', this._resources.toReference())\n    return xobj\n  }\n\n  // while most parts of the header is static (i.e. rendered only once and then reused), there are\n  // some dynamic parts (e.g. page numbers) which are rendered on each page\n  // these parts are rendered here\n  async _render() {\n    if (this._pageNumbers.length === 0) {\n      return\n    }\n\n    // lazy load text, because of cyclic dependencies of Fragment\n    const Text = require('./text')\n\n    for (const instance of this._pageNumbers) {\n      let withPageCount = false\n      if (instance.fn) {\n        const lhs = instance.fn(1, 1)\n        const rhs = instance.fn(1, 10)\n        withPageCount = lhs.length !== rhs.length\n      }\n\n      // postpone writing page number until the end of the document, because the total page count\n      // is not known now\n      if (withPageCount) {\n        // since there is only text with an already known font, the fonts dictionary can already\n        // be build\n        const fonts = new PDF.Dictionary({})\n        const font = this._doc._fontInstance(instance.opts.font || this._doc.defaultFont)\n        const fontAlias = this._doc._fontAlias(font)\n        fonts.set(fontAlias, this._doc._fonts[fontAlias].o.toReference())\n\n        // create the FormXObject that is used to render the page numbers\n        const xobj = new PDF.Object('XObject')\n        xobj.prop('Subtype', 'Form')\n        xobj.prop('FormType', 1)\n        xobj.prop('BBox', new PDF.Array([instance.x, instance.y, instance.x + instance.width, instance.y - instance.height]))\n        xobj.prop('Resources', new PDF.Dictionary({\n          ColorSpace: new PDF.Dictionary({\n            CS1: new PDF.Array([new PDF.Name('ICCBased'), this._doc._colorSpace.toReference()]),\n          }),\n          ProcSet: new PDF.Array([new PDF.Name('Text')]),\n          Font:    fonts,\n        }))\n        this._doc._registerObject(xobj)\n\n        // calculate the number of the currently rendered page\n        const currentPage = this._doc._pages.length\n\n        // add a handler to the document that will be called when the document is finished up\n        // this is necessary because the total count of pages is not yet known\n        this._doc._finalize.push(async () => {\n          await this._doc._startContentObject(xobj)\n\n          // setup the cursor to the position the page numbers should be rendered at\n          this._cursor.y = instance.y\n          this._cursor.x = instance.x\n          this._cursor.width = instance.width\n\n          // negate document bottomOffset, which is there because of this header\n          this._cursor.bottomOffset = -this._doc._cursor.bottomOffset\n\n          // create the text representing the page numbers\n          const pageCount =  this._doc._pages.length\n          const str = instance.fn ? instance.fn(currentPage, pageCount) : currentPage\n\n          // manually render the text\n          const txt = new Text(this._doc, this, instance.opts)\n          txt._parts++\n          txt._ended = true\n          await txt._start()\n          await txt._render(str, instance.opts)\n          await txt._end()\n\n          await this._doc._endContentObject()\n        })\n\n        // render and register the FormXObject to the current page\n        const alias = new PDF.Name(this._doc._aliases.next('X'))\n        this._doc._currentContent._xobjects[alias] = xobj.toReference()\n        await this._doc._write(ops.Do(alias))\n      } else {\n        // if there is now total page count necessary, we can write the current page number directly\n        this._cursor.y = instance.y\n        this._cursor.x = instance.x\n        this._cursor.width = instance.width\n\n        // negate document bottomOffset, which is there because of this header\n        this._cursor.bottomOffset = -this._doc._cursor.bottomOffset\n\n        const txt = new Text(this._doc, this, instance.opts)\n        txt._parts++\n        txt._ended = true\n        await txt._start()\n        await txt._render(String(this._doc._pages.length), instance.opts)\n        await txt._end()\n      }\n    }\n  }\n\n  async _end() {\n    // save the height of the header\n    // this is used to correctly offset the cursor when rendering the page\n    this.height = this._doc._cursor.startY - this._doc._cursor.y\n\n    await this._doc._endContentObject()\n\n    // collect all fonts and xobjects that are used in the header\n    for (const content of this._doc._contents) {\n      for (const alias in content._fonts) {\n        this.fonts.add(alias, content._fonts[alias])\n      }\n\n      for (const alias in content._xobjects) {\n        this.xobjects.add(alias, content._xobjects[alias])\n      }\n    }\n\n    // create the Resources object for the header's FormXObjects\n    this._resources.content = new PDF.Dictionary({\n      ColorSpace: new PDF.Dictionary({\n        CS1: new PDF.Array([new PDF.Name('ICCBased'), this._doc._colorSpace.toReference()]),\n      }),\n      ProcSet: new PDF.Array([\n        new PDF.Name('PDF'),\n        new PDF.Name('Text'),\n        new PDF.Name('ImageB'),\n        new PDF.Name('ImageC'),\n        new PDF.Name('ImageI')\n      ]),\n      Font:    this.fonts,\n      XObject: this.xobjects\n    })\n    await this._doc._writeObject(this._resources)\n\n    // setup the BBox\n    this._bbox.content = new PDF.Array([\n      this._cursor.startX, this._cursor.startY,\n      this._cursor.startX + this._doc._cursor.width, this._doc._cursor.y\n    ])\n    await this._doc._writeObject(this._bbox)\n\n    // the header can consist out of multiple FormXObjects, which are collected here\n    this._objects = this._doc._contents.map(c => c._object)\n\n    // reset everything\n    this._doc._cursor.reset()\n\n    this._doc._currentContent = null\n    this._doc._contents.length = 0\n\n    this._doc._contentObjCreator = null\n\n    this._cursor.y -= this.height\n  }\n\n  /// public API\n\n  pageNumber(fn, opts) {\n    if (typeof fn === 'object') {\n      opts = fn\n      fn = undefined\n    }\n\n    if (!opts || typeof opts !== 'object') {\n      opts = {}\n    }\n\n    const font = this._doc._fontInstance(opts.font || this._doc.defaultFont)\n    const fontSize = opts.fontSize || this._doc.defaultFontSize\n    const lineHeight = opts.lineHeight || this._doc.defaultLineHeight\n\n    const height = font.lineHeight(fontSize, true) * lineHeight\n    const descent = -font.descent(fontSize) * lineHeight\n\n    this._begin(null)\n    this._pending.push(() => {\n      this._pageNumbers.push({\n        y: this._cursor.y,\n        x: this._cursor.x,\n        width: this._cursor.width,\n        height: height + descent,\n        opts: opts,\n        fn: fn\n      })\n\n      this._cursor.y -= height + descent\n      return Promise.resolve()\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}