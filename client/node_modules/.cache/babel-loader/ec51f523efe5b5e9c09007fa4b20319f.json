{"ast":null,"code":"'use strict';\n\nconst Lexer = require('../parser/lexer');\n\nclass PDFString {\n  constructor(str) {\n    this.str = str;\n  }\n\n  toHexString() {\n    // convert to hex string\n    let hex = '';\n\n    for (let i = 0, len = this.str.length; i < len; ++i) {\n      let h = (this.str.charCodeAt(i) - 31).toString(16); // left pad zeroes\n\n      h = ('0000' + h).slice(-4);\n      hex += h;\n    }\n\n    return '<' + hex + '>';\n  }\n\n  toString() {\n    return '(' + this.str.replace(/\\\\/g, '\\\\\\\\').replace(/\\(/g, '\\\\(').replace(/\\)/g, '\\\\)') + ')';\n  }\n\n  static parse(xref, lexer, trial) {\n    const literal = PDFString.parseLiteral(lexer, trial);\n    const hex = literal === undefined && PDFString.parseHex(lexer, trial);\n\n    if (!literal && !hex) {\n      if (trial) {\n        return undefined;\n      }\n\n      throw new Error('Invalid string');\n    }\n\n    return literal || hex;\n  }\n\n  static parseLiteral(lexer, trial) {\n    if (lexer.getString(1) !== '(') {\n      if (trial) {\n        return undefined;\n      }\n\n      throw new Error('Invalid literal string');\n    }\n\n    lexer.shift(1);\n    let str = '';\n    let done = false;\n    let open = 0;\n    let c;\n\n    while (!done && (c = lexer._nextCharCode()) >= 0) {\n      switch (c) {\n        case 0x28:\n          // (\n          open++;\n          str += String.fromCharCode('(');\n          break;\n\n        case 0x29:\n          // )\n          if (open === 0) {\n            done = true;\n          } else {\n            open--;\n            str += String.fromCharCode(')');\n          }\n\n          break;\n\n        case 0x5c:\n          // \\\n          c = lexer._nextCharCode();\n\n          switch (c) {\n            case 0x6e:\n              // \\n\n              str += '\\n';\n              break;\n\n            case 0x72:\n              // \\r\n              str += '\\r';\n              break;\n\n            case 0x74:\n              // \\t\n              str += '\\t';\n              break;\n\n            case 0x62:\n              // \\b\n              str += '\\b';\n              break;\n\n            case 0x66:\n              // \\f\n              str += '\\f';\n              break;\n\n            case 0x28: // '('\n\n            case 0x29: // ')'\n\n            case 0x5c:\n              // '\\'\n              str += String.fromCharCode(c);\n              break;\n\n            case 0x30: // 0\n\n            case 0x31: // 1\n\n            case 0x32: // 2\n\n            case 0x33: // 3\n\n            case 0x34: // 4\n\n            case 0x35: // 5\n\n            case 0x36: // 6\n\n            case 0x37: // 7\n\n            case 0x38: // 8\n\n            case 0x39:\n              // 9\n              const oct = String.fromCharCode(c) + lexer.readString(2);\n              str += String.fromCharCode(parseInt(oct, 8));\n              break;\n\n            default:\n              lexer.shift(-1);\n              break;\n          }\n\n          break;\n\n        case 0x0d: // CR\n\n        case 0x0a:\n          // LF\n          // ignore EOL characters\n          break;\n\n        default:\n          str += String.fromCharCode(c);\n          break;\n      }\n    }\n\n    return new PDFString(str);\n  }\n\n  static parseHex(lexer, trial) {\n    if (lexer.getString(1) !== '<') {\n      if (trial) {\n        return undefined;\n      }\n\n      throw new Error('Invalid hex string');\n    }\n\n    lexer.shift(1);\n    let str = '';\n    let done = false;\n    const digits = [];\n\n    const addCharacter = function (force) {\n      if (digits.length !== 2) {\n        if (digits.length === 1 && force) {\n          digits.push('0');\n        } else {\n          return;\n        }\n      }\n\n      str += String.fromCharCode(parseInt(digits.join(''), 16));\n      digits.length = 0;\n    };\n\n    let c;\n\n    while (!done && (c = lexer._nextCharCode()) >= 0) {\n      switch (true) {\n        case c === 0x3e:\n          // >\n          done = true;\n          break;\n\n        case c >= 0x30 && c <= 0x39: // 0 - 9\n\n        case c >= 0x41 && c <= 0x5a: // A - B\n\n        case c >= 0x61 && c <= 0x7a:\n          // a - b\n          digits.push(String.fromCharCode(c));\n          addCharacter();\n          break;\n\n        case Lexer.isWhiteSpace(c):\n          break;\n\n        default:\n          lexer._warning('invalid character `' + String.fromCharCode(c) + '` in hex string');\n\n          break;\n      }\n    }\n\n    addCharacter(true);\n    return new PDFString(str);\n  }\n\n}\n\nmodule.exports = PDFString;","map":{"version":3,"sources":["/mnt/c/Users/Venkatesh/Documents/6th Sem/Web Dev/project/resume-generator/node_modules/pdfjs/lib/object/string.js"],"names":["Lexer","require","PDFString","constructor","str","toHexString","hex","i","len","length","h","charCodeAt","toString","slice","replace","parse","xref","lexer","trial","literal","parseLiteral","undefined","parseHex","Error","getString","shift","done","open","c","_nextCharCode","String","fromCharCode","oct","readString","parseInt","digits","addCharacter","force","push","join","isWhiteSpace","_warning","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,iBAAD,CAArB;;AAEA,MAAMC,SAAN,CAAgB;AACdC,EAAAA,WAAW,CAACC,GAAD,EAAM;AACf,SAAKA,GAAL,GAAWA,GAAX;AACD;;AAEDC,EAAAA,WAAW,GAAG;AACZ;AACA,QAAIC,GAAG,GAAG,EAAV;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAG,KAAKJ,GAAL,CAASK,MAA/B,EAAuCF,CAAC,GAAGC,GAA3C,EAAgD,EAAED,CAAlD,EAAqD;AACnD,UAAIG,CAAC,GAAG,CAAC,KAAKN,GAAL,CAASO,UAAT,CAAoBJ,CAApB,IAAyB,EAA1B,EAA8BK,QAA9B,CAAuC,EAAvC,CAAR,CADmD,CAEnD;;AACAF,MAAAA,CAAC,GAAG,CAAC,SAASA,CAAV,EAAaG,KAAb,CAAmB,CAAC,CAApB,CAAJ;AACAP,MAAAA,GAAG,IAAII,CAAP;AACD;;AACD,WAAO,MAAMJ,GAAN,GAAY,GAAnB;AACD;;AAEDM,EAAAA,QAAQ,GAAG;AACT,WAAO,MAAM,KAAKR,GAAL,CAASU,OAAT,CAAiB,KAAjB,EAAwB,MAAxB,EACSA,OADT,CACiB,KADjB,EACwB,KADxB,EAESA,OAFT,CAEiB,KAFjB,EAEwB,KAFxB,CAAN,GAEuC,GAF9C;AAGD;;AAEW,SAALC,KAAK,CAACC,IAAD,EAAOC,KAAP,EAAcC,KAAd,EAAqB;AAC/B,UAAMC,OAAO,GAAGjB,SAAS,CAACkB,YAAV,CAAuBH,KAAvB,EAA8BC,KAA9B,CAAhB;AACA,UAAMZ,GAAG,GAAGa,OAAO,KAAKE,SAAZ,IAAyBnB,SAAS,CAACoB,QAAV,CAAmBL,KAAnB,EAA0BC,KAA1B,CAArC;;AAEA,QAAI,CAACC,OAAD,IAAY,CAACb,GAAjB,EAAsB;AACpB,UAAIY,KAAJ,EAAW;AACT,eAAOG,SAAP;AACD;;AAED,YAAM,IAAIE,KAAJ,CAAU,gBAAV,CAAN;AACD;;AAED,WAAOJ,OAAO,IAAIb,GAAlB;AACD;;AAEkB,SAAZc,YAAY,CAACH,KAAD,EAAQC,KAAR,EAAe;AAChC,QAAID,KAAK,CAACO,SAAN,CAAgB,CAAhB,MAAuB,GAA3B,EAAgC;AAC9B,UAAIN,KAAJ,EAAW;AACT,eAAOG,SAAP;AACD;;AAED,YAAM,IAAIE,KAAJ,CAAU,wBAAV,CAAN;AACD;;AAEDN,IAAAA,KAAK,CAACQ,KAAN,CAAY,CAAZ;AAEA,QAAIrB,GAAG,GAAG,EAAV;AAEA,QAAIsB,IAAI,GAAG,KAAX;AACA,QAAIC,IAAI,GAAG,CAAX;AACA,QAAIC,CAAJ;;AACA,WAAO,CAACF,IAAD,IAAS,CAACE,CAAC,GAAGX,KAAK,CAACY,aAAN,EAAL,KAA+B,CAA/C,EAAkD;AAChD,cAAQD,CAAR;AACE,aAAK,IAAL;AAAW;AACTD,UAAAA,IAAI;AACJvB,UAAAA,GAAG,IAAI0B,MAAM,CAACC,YAAP,CAAoB,GAApB,CAAP;AACA;;AACF,aAAK,IAAL;AAAW;AACT,cAAIJ,IAAI,KAAK,CAAb,EAAgB;AACdD,YAAAA,IAAI,GAAG,IAAP;AACD,WAFD,MAEO;AACLC,YAAAA,IAAI;AACJvB,YAAAA,GAAG,IAAI0B,MAAM,CAACC,YAAP,CAAoB,GAApB,CAAP;AACD;;AACD;;AACF,aAAK,IAAL;AAAW;AACTH,UAAAA,CAAC,GAAGX,KAAK,CAACY,aAAN,EAAJ;;AACA,kBAAQD,CAAR;AACE,iBAAK,IAAL;AAAW;AACTxB,cAAAA,GAAG,IAAI,IAAP;AACA;;AACF,iBAAK,IAAL;AAAW;AACTA,cAAAA,GAAG,IAAI,IAAP;AACA;;AACF,iBAAK,IAAL;AAAW;AACTA,cAAAA,GAAG,IAAI,IAAP;AACA;;AACF,iBAAK,IAAL;AAAW;AACTA,cAAAA,GAAG,IAAI,IAAP;AACA;;AACF,iBAAK,IAAL;AAAW;AACTA,cAAAA,GAAG,IAAI,IAAP;AACA;;AACF,iBAAK,IAAL,CAhBF,CAgBa;;AACX,iBAAK,IAAL,CAjBF,CAiBa;;AACX,iBAAK,IAAL;AAAW;AACTA,cAAAA,GAAG,IAAI0B,MAAM,CAACC,YAAP,CAAoBH,CAApB,CAAP;AACA;;AACF,iBAAK,IAAL,CArBF,CAqBa;;AACX,iBAAK,IAAL,CAtBF,CAsBa;;AACX,iBAAK,IAAL,CAvBF,CAuBa;;AACX,iBAAK,IAAL,CAxBF,CAwBa;;AACX,iBAAK,IAAL,CAzBF,CAyBa;;AACX,iBAAK,IAAL,CA1BF,CA0Ba;;AACX,iBAAK,IAAL,CA3BF,CA2Ba;;AACX,iBAAK,IAAL,CA5BF,CA4Ba;;AACX,iBAAK,IAAL,CA7BF,CA6Ba;;AACX,iBAAK,IAAL;AAAW;AACT,oBAAMI,GAAG,GAAGF,MAAM,CAACC,YAAP,CAAoBH,CAApB,IAAyBX,KAAK,CAACgB,UAAN,CAAiB,CAAjB,CAArC;AACA7B,cAAAA,GAAG,IAAI0B,MAAM,CAACC,YAAP,CAAoBG,QAAQ,CAACF,GAAD,EAAM,CAAN,CAA5B,CAAP;AACA;;AACF;AACEf,cAAAA,KAAK,CAACQ,KAAN,CAAY,CAAC,CAAb;AACA;AApCJ;;AAsCA;;AACF,aAAK,IAAL,CAtDF,CAsDa;;AACX,aAAK,IAAL;AAAW;AACT;AACA;;AACF;AACErB,UAAAA,GAAG,IAAI0B,MAAM,CAACC,YAAP,CAAoBH,CAApB,CAAP;AACA;AA5DJ;AA8DD;;AAED,WAAO,IAAI1B,SAAJ,CAAcE,GAAd,CAAP;AACD;;AAEc,SAARkB,QAAQ,CAACL,KAAD,EAAQC,KAAR,EAAe;AAC5B,QAAID,KAAK,CAACO,SAAN,CAAgB,CAAhB,MAAuB,GAA3B,EAAgC;AAC9B,UAAIN,KAAJ,EAAW;AACT,eAAOG,SAAP;AACD;;AAED,YAAM,IAAIE,KAAJ,CAAU,oBAAV,CAAN;AACD;;AAEDN,IAAAA,KAAK,CAACQ,KAAN,CAAY,CAAZ;AAEA,QAAIrB,GAAG,GAAG,EAAV;AAEA,QAAIsB,IAAI,GAAG,KAAX;AACA,UAAMS,MAAM,GAAG,EAAf;;AACA,UAAMC,YAAY,GAAG,UAASC,KAAT,EAAgB;AACnC,UAAIF,MAAM,CAAC1B,MAAP,KAAkB,CAAtB,EAAyB;AACvB,YAAI0B,MAAM,CAAC1B,MAAP,KAAkB,CAAlB,IAAuB4B,KAA3B,EAAkC;AAChCF,UAAAA,MAAM,CAACG,IAAP,CAAY,GAAZ;AACD,SAFD,MAEO;AACL;AACD;AACF;;AAEDlC,MAAAA,GAAG,IAAI0B,MAAM,CAACC,YAAP,CAAoBG,QAAQ,CAACC,MAAM,CAACI,IAAP,CAAY,EAAZ,CAAD,EAAkB,EAAlB,CAA5B,CAAP;AACAJ,MAAAA,MAAM,CAAC1B,MAAP,GAAgB,CAAhB;AACD,KAXD;;AAaA,QAAImB,CAAJ;;AACA,WAAO,CAACF,IAAD,IAAS,CAACE,CAAC,GAAGX,KAAK,CAACY,aAAN,EAAL,KAA+B,CAA/C,EAAkD;AAChD,cAAQ,IAAR;AACE,aAAKD,CAAC,KAAK,IAAX;AAAiB;AACfF,UAAAA,IAAI,GAAG,IAAP;AACA;;AACF,aAAKE,CAAC,IAAI,IAAL,IAAaA,CAAC,IAAI,IAAvB,CAJF,CAI+B;;AAC7B,aAAKA,CAAC,IAAI,IAAL,IAAaA,CAAC,IAAI,IAAvB,CALF,CAK+B;;AAC7B,aAAKA,CAAC,IAAI,IAAL,IAAaA,CAAC,IAAI,IAAvB;AAA6B;AAC3BO,UAAAA,MAAM,CAACG,IAAP,CAAYR,MAAM,CAACC,YAAP,CAAoBH,CAApB,CAAZ;AACAQ,UAAAA,YAAY;AACZ;;AACF,aAAKpC,KAAK,CAACwC,YAAN,CAAmBZ,CAAnB,CAAL;AACE;;AACF;AACEX,UAAAA,KAAK,CAACwB,QAAN,CAAe,wBAAwBX,MAAM,CAACC,YAAP,CAAoBH,CAApB,CAAxB,GAAiD,iBAAhE;;AACA;AAdJ;AAgBD;;AAEDQ,IAAAA,YAAY,CAAC,IAAD,CAAZ;AAEA,WAAO,IAAIlC,SAAJ,CAAcE,GAAd,CAAP;AACD;;AA7Ka;;AAgLhBsC,MAAM,CAACC,OAAP,GAAiBzC,SAAjB","sourcesContent":["'use strict'\n\nconst Lexer = require('../parser/lexer')\n\nclass PDFString {\n  constructor(str) {\n    this.str = str\n  }\n\n  toHexString() {\n    // convert to hex string\n    let hex = ''\n    for (let i = 0, len = this.str.length; i < len; ++i) {\n      let h = (this.str.charCodeAt(i) - 31).toString(16)\n      // left pad zeroes\n      h = ('0000' + h).slice(-4)\n      hex += h\n    }\n    return '<' + hex + '>'\n  }\n\n  toString() {\n    return '(' + this.str.replace(/\\\\/g, '\\\\\\\\')\n                         .replace(/\\(/g, '\\\\(')\n                         .replace(/\\)/g, '\\\\)') + ')'\n  }\n\n  static parse(xref, lexer, trial) {\n    const literal = PDFString.parseLiteral(lexer, trial)\n    const hex = literal === undefined && PDFString.parseHex(lexer, trial)\n\n    if (!literal && !hex) {\n      if (trial) {\n        return undefined\n      }\n\n      throw new Error('Invalid string')\n    }\n\n    return literal || hex\n  }\n\n  static parseLiteral(lexer, trial) {\n    if (lexer.getString(1) !== '(') {\n      if (trial) {\n        return undefined\n      }\n\n      throw new Error('Invalid literal string')\n    }\n\n    lexer.shift(1)\n\n    let str = ''\n\n    let done = false\n    let open = 0\n    let c\n    while (!done && (c = lexer._nextCharCode()) >= 0) {\n      switch (c) {\n        case 0x28: // (\n          open++\n          str += String.fromCharCode('(')\n          break\n        case 0x29: // )\n          if (open === 0) {\n            done = true\n          } else {\n            open--\n            str += String.fromCharCode(')')\n          }\n          break\n        case 0x5c: // \\\n          c = lexer._nextCharCode()\n          switch (c) {\n            case 0x6e: // \\n\n              str += '\\n'\n              break\n            case 0x72: // \\r\n              str += '\\r'\n              break\n            case 0x74: // \\t\n              str += '\\t'\n              break\n            case 0x62: // \\b\n              str += '\\b'\n              break\n            case 0x66: // \\f\n              str += '\\f'\n              break\n            case 0x28: // '('\n            case 0x29: // ')'\n            case 0x5c: // '\\'\n              str += String.fromCharCode(c)\n              break\n            case 0x30: // 0\n            case 0x31: // 1\n            case 0x32: // 2\n            case 0x33: // 3\n            case 0x34: // 4\n            case 0x35: // 5\n            case 0x36: // 6\n            case 0x37: // 7\n            case 0x38: // 8\n            case 0x39: // 9\n              const oct = String.fromCharCode(c) + lexer.readString(2)\n              str += String.fromCharCode(parseInt(oct, 8))\n              break\n            default:\n              lexer.shift(-1)\n              break\n          }\n          break\n        case 0x0d: // CR\n        case 0x0a: // LF\n          // ignore EOL characters\n          break\n        default:\n          str += String.fromCharCode(c)\n          break\n      }\n    }\n\n    return new PDFString(str)\n  }\n\n  static parseHex(lexer, trial) {\n    if (lexer.getString(1) !== '<') {\n      if (trial) {\n        return undefined\n      }\n\n      throw new Error('Invalid hex string')\n    }\n\n    lexer.shift(1)\n\n    let str = ''\n\n    let done = false\n    const digits = []\n    const addCharacter = function(force) {\n      if (digits.length !== 2) {\n        if (digits.length === 1 && force) {\n          digits.push('0')\n        } else {\n          return\n        }\n      }\n\n      str += String.fromCharCode(parseInt(digits.join(''), 16))\n      digits.length = 0\n    }\n\n    let c\n    while (!done && (c = lexer._nextCharCode()) >= 0) {\n      switch (true) {\n        case c === 0x3e: // >\n          done = true\n          break\n        case c >= 0x30 && c <= 0x39: // 0 - 9\n        case c >= 0x41 && c <= 0x5a: // A - B\n        case c >= 0x61 && c <= 0x7a: // a - b\n          digits.push(String.fromCharCode(c))\n          addCharacter()\n          break\n        case Lexer.isWhiteSpace(c):\n          break\n        default:\n          lexer._warning('invalid character `' + String.fromCharCode(c) + '` in hex string')\n          break\n      }\n    }\n\n    addCharacter(true)\n\n    return new PDFString(str)\n  }\n}\n\nmodule.exports = PDFString\n"]},"metadata":{},"sourceType":"script"}