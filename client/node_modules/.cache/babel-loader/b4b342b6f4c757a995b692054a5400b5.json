{"ast":null,"code":"'use strict';\n\nconst PDFDictionary = require('./dictionary');\n\nconst PDFReference = require('./reference');\n\nconst PDFValue = require('./value');\n\nclass PDFObject {\n  constructor(type) {\n    this.id = null;\n    this.rev = 0;\n    this.properties = new PDFDictionary();\n    this.reference = new PDFReference(this);\n    this.content = null;\n\n    if (type) {\n      this.prop('Type', type);\n    } // TODO: still necessary?\n    // used to have obj.object API for both indirect and direct objects\n    //   this.object = this\n\n  }\n\n  prop(key, val) {\n    this.properties.add(key, val);\n  }\n\n  toReference() {\n    return this.reference;\n  }\n\n  toString() {\n    return this.id.toString() + ' ' + this.rev + ' obj\\n' + (this.properties.length ? this.properties.toString() + '\\n' : '') + (this.content !== null ? this.content.toString() + '\\n' : '') + 'endobj';\n  }\n\n  static parse(xref, lexer, trial) {\n    const before = lexer.pos;\n    lexer.skipWhitespace(null, true);\n    const id = lexer.readNumber(trial);\n\n    if (id === undefined && !trial) {\n      throw new Error('Invalid object');\n    }\n\n    lexer.skipWhitespace(1, trial);\n    const generation = lexer.readNumber(trial);\n\n    if (generation === undefined && !trial) {\n      throw new Error('Invalid object');\n    }\n\n    lexer.skipWhitespace(1, trial);\n\n    if (lexer.getString(3) !== 'obj') {\n      if (trial) {\n        lexer.pos = before;\n        return undefined;\n      }\n\n      throw new Error('Invalid object');\n    }\n\n    lexer.shift(3);\n    lexer.skipEOL(1, true);\n    lexer.skipWhitespace(null, true);\n    const obj = PDFObject.parseInner(xref, lexer);\n    lexer.skipWhitespace(null, true);\n\n    if (lexer.readString(3) !== 'end') {\n      throw new Error('Invalid object: `end` not found');\n    }\n\n    return obj;\n  }\n\n  static parseInner(xref, lexer) {\n    const value = PDFValue.parse(xref, lexer, true);\n\n    if (value === undefined) {\n      throw new Error('Empty object');\n    }\n\n    lexer.skipWhitespace(null, true);\n    const obj = new PDFObject();\n\n    if (value instanceof PDFDictionary) {\n      obj.properties = value;\n\n      if (lexer.getString(6) === 'stream') {\n        lexer.shift(6);\n        lexer.skipEOL(1);\n        let length = obj.properties.get('Length');\n\n        if (length === undefined) {\n          throw new Error('Invalid Stream: no length specified');\n        }\n\n        if (typeof length === 'object') {\n          const pos = lexer.pos;\n          length = length.object.content;\n          lexer.pos = pos;\n        }\n\n        const PDFStream = require('./stream'); // lazy load, cause circular referecnes\n\n\n        const stream = new PDFStream(obj);\n        stream.content = lexer.read(length);\n        lexer.skipEOL(1, true); // not to be expected according to the PDF spec, but there are some PDF files that indent\n        // the stream\n\n        lexer.skipWhitespace(null, true);\n\n        if (lexer.readString(9) !== 'endstream') {\n          throw new Error('Invalid stream: `endstream` not found');\n        }\n\n        lexer.skipEOL(1, true);\n      }\n    } else {\n      obj.content = value;\n    }\n\n    return obj;\n  }\n\n}\n\nmodule.exports = PDFObject;","map":{"version":3,"sources":["/mnt/c/Users/Venkatesh/Documents/6th Sem/Web Dev/project/resume-generator/node_modules/pdfjs/lib/object/object.js"],"names":["PDFDictionary","require","PDFReference","PDFValue","PDFObject","constructor","type","id","rev","properties","reference","content","prop","key","val","add","toReference","toString","length","parse","xref","lexer","trial","before","pos","skipWhitespace","readNumber","undefined","Error","generation","getString","shift","skipEOL","obj","parseInner","readString","value","get","object","PDFStream","stream","read","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PDFDictionary = require('./dictionary')\nconst PDFReference  = require('./reference')\nconst PDFValue = require('./value')\n\nclass PDFObject {\n  constructor(type) {\n    this.id         = null\n    this.rev        = 0\n    this.properties = new PDFDictionary()\n    this.reference  = new PDFReference(this)\n    this.content    = null\n\n    if (type) {\n      this.prop('Type', type)\n    }\n\n    // TODO: still necessary?\n    // used to have obj.object API for both indirect and direct objects\n    //   this.object = this\n  }\n\n  prop(key, val) {\n    this.properties.add(key, val)\n  }\n\n  toReference() {\n    return this.reference\n  }\n\n  toString() {\n    return this.id.toString() + ' ' + this.rev + ' obj\\n' +\n           (this.properties.length ? this.properties.toString() + '\\n' : '') +\n           (this.content !== null ? this.content.toString() + '\\n' : '') +\n           'endobj'\n  }\n\n  static parse(xref, lexer, trial) {\n    const before = lexer.pos\n\n    lexer.skipWhitespace(null, true)\n    const id = lexer.readNumber(trial)\n    if (id === undefined && !trial) {\n      throw new Error('Invalid object')\n    }\n    lexer.skipWhitespace(1, trial)\n    const generation = lexer.readNumber(trial)\n    if (generation === undefined && !trial) {\n      throw new Error('Invalid object')\n    }\n\n    lexer.skipWhitespace(1, trial)\n    if (lexer.getString(3) !== 'obj') {\n      if (trial) {\n        lexer.pos = before\n        return undefined\n      }\n\n      throw new Error('Invalid object')\n    }\n\n    lexer.shift(3)\n\n    lexer.skipEOL(1, true)\n    lexer.skipWhitespace(null, true)\n\n    const obj = PDFObject.parseInner(xref, lexer)\n\n    lexer.skipWhitespace(null, true)\n\n    if (lexer.readString(3) !== 'end') {\n      throw new Error('Invalid object: `end` not found')\n    }\n\n    return obj\n  }\n\n  static parseInner(xref, lexer) {\n    const value = PDFValue.parse(xref, lexer, true)\n    if (value === undefined) {\n      throw new Error('Empty object')\n    }\n\n    lexer.skipWhitespace(null, true)\n\n    const obj = new PDFObject()\n    if (value instanceof PDFDictionary) {\n      obj.properties = value\n\n      if (lexer.getString(6) === 'stream') {\n        lexer.shift(6)\n        lexer.skipEOL(1)\n\n        let length = obj.properties.get('Length')\n        if (length === undefined) {\n          throw new Error('Invalid Stream: no length specified')\n        }\n\n        if (typeof length === 'object') {\n          const pos = lexer.pos\n          length = length.object.content\n          lexer.pos = pos\n        }\n\n        const PDFStream = require('./stream') // lazy load, cause circular referecnes\n        const stream = new PDFStream(obj)\n        stream.content = lexer.read(length)\n        lexer.skipEOL(1, true)\n\n        // not to be expected according to the PDF spec, but there are some PDF files that indent\n        // the stream\n        lexer.skipWhitespace(null, true)\n\n        if (lexer.readString(9) !== 'endstream') {\n          throw new Error('Invalid stream: `endstream` not found')\n        }\n\n        lexer.skipEOL(1, true)\n      }\n    } else {\n      obj.content = value\n    }\n\n    return obj\n  }\n}\n\nmodule.exports = PDFObject\n"]},"metadata":{},"sourceType":"script"}