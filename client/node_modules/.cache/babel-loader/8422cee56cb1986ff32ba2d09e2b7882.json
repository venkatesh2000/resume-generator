{"ast":null,"code":"'use strict';\n\nconst PDFObject = require('./object');\n\nconst util = require('../util');\n\nmodule.exports = class PDFXref {\n  constructor() {\n    this.objects = [];\n    this.trailer = null;\n  }\n\n  add(id, data) {\n    this.objects[id] = data;\n  }\n\n  get(id) {\n    return this.objects[id] && this.objects[id].obj;\n  }\n\n  getOffset(id) {\n    return this.objects[id] && this.objects[id].offset || null;\n  }\n\n  toString() {\n    let xref = 'xref\\n';\n    let range = {\n      from: 0,\n      refs: [0]\n    };\n    const ranges = [range];\n\n    for (let i = 1; i < this.objects.length; ++i) {\n      const obj = this.objects[i];\n\n      if (!obj) {\n        if (range) {\n          range = null;\n        }\n\n        continue;\n      }\n\n      if (!range) {\n        range = {\n          from: i,\n          refs: []\n        };\n        ranges.push(range);\n      }\n\n      range.refs.push(obj.offset);\n    }\n\n    ranges.forEach(function (range) {\n      xref += range.from + ' ' + range.refs.length + '\\n';\n      range.refs.forEach(function (ref, i) {\n        if (range.from === 0 && i === 0) {\n          xref += '0000000000 65535 f \\n';\n        } else {\n          xref += '0000000000'.substr(ref.toString().length) + ref + ' 00000 n \\n';\n        }\n      });\n    });\n    return xref;\n  }\n\n  static parse(_, lexer, trial) {\n    const xref = new PDFXref();\n\n    if (lexer.getString(4) !== 'xref') {\n      return this.parseXrefObject(_, lexer, trial);\n    }\n\n    lexer.readString(4); // skip xref\n\n    lexer.skipSpace(null, trial);\n    lexer.skipEOL(1, trial);\n    let start;\n\n    while ((start = lexer.readNumber(true)) !== undefined) {\n      lexer.skipSpace(1);\n      const count = lexer.readNumber();\n      lexer.skipSpace(null, true);\n      lexer.skipEOL(1);\n\n      for (let i = 0, len = 0 + count; i < len; ++i) {\n        const offset = lexer.readNumber();\n        lexer.skipSpace(1);\n        lexer.readNumber(); // generation\n\n        lexer.skipSpace(1);\n        const key = lexer.readString(1);\n        lexer.skipSpace(null, true);\n        lexer.skipEOL(1);\n        const id = start + i;\n\n        if (id > 0 && key === 'n') {\n          xref.add(id, {\n            offset: offset\n          });\n        }\n      }\n    }\n\n    return xref;\n  } // TODO: this implementation needs to be improved\n\n\n  static parseXrefObject(_, lexer, trial) {\n    const xref = new PDFXref();\n    let obj;\n\n    try {\n      obj = PDFObject.parse(xref, lexer, trial);\n    } catch (_) {\n      throw new Error('Invalid xref: xref expected but not found');\n    }\n\n    let kind = obj.properties.get(\"Type\");\n\n    if (!kind || kind.name !== \"XRef\") {\n      throw new Error(\"Invalid xref object at \" + lexer.pos);\n    }\n\n    const stream = util.inflate(obj);\n    xref.trailer = obj.properties;\n    const index = obj.properties.get(\"Index\");\n    const start = index ? index[0] : 0;\n    const w = obj.properties.get(\"W\");\n    const typeSize = w[0] || 1;\n    const offsetSize = w[1] || 2;\n    const genSize = w[2] || 1;\n    const len = stream.length / (typeSize + offsetSize + genSize);\n    let pos = 0;\n\n    for (let i = 0; i < len; ++i) {\n      const type = readUint(stream, pos, typeSize);\n      pos += typeSize;\n      const offset = readUint(stream, pos, offsetSize);\n      pos += offsetSize;\n\n      switch (type) {\n        case 0:\n          // free\n          pos += genSize;\n          continue;\n        // skip type 0 entries (free entries)\n\n        case 1:\n          // normal\n          xref.add(start + i, {\n            offset\n          });\n          pos += genSize;\n          break;\n\n        case 2:\n          // compressed\n          xref.add(start + i, {\n            compressed: true,\n            id: offset,\n            ix: readUint(stream, pos, genSize)\n          });\n          pos += genSize;\n          break;\n\n        default:\n          continue;\n      }\n    }\n\n    return xref;\n  }\n\n};\n\nfunction readUint(src, pos, size) {\n  let val = 0;\n\n  for (let i = 0; i < size; ++i) {\n    // for (let i = size - 1; i > 0; --i) {\n    val += src[pos + size - i - 1] << 8 * i;\n  }\n\n  return val;\n}","map":{"version":3,"sources":["/mnt/c/Users/Venkatesh/Documents/6th Sem/Web Dev/project/resume-generator/node_modules/pdfjs/lib/object/xref.js"],"names":["PDFObject","require","util","module","exports","PDFXref","constructor","objects","trailer","add","id","data","get","obj","getOffset","offset","toString","xref","range","from","refs","ranges","i","length","push","forEach","ref","substr","parse","_","lexer","trial","getString","parseXrefObject","readString","skipSpace","skipEOL","start","readNumber","undefined","count","len","key","Error","kind","properties","name","pos","stream","inflate","index","w","typeSize","offsetSize","genSize","type","readUint","compressed","ix","src","size","val"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PDFObject = require('./object')\nconst util = require('../util')\n\nmodule.exports = class PDFXref {\n  constructor() {\n    this.objects = []\n    this.trailer = null\n  }\n\n  add(id, data) {\n    this.objects[id] = data\n  }\n\n  get(id) {\n    return this.objects[id] && this.objects[id].obj\n  }\n\n  getOffset(id) {\n    return this.objects[id] && this.objects[id].offset || null\n  }\n\n  toString() {\n    let xref = 'xref\\n'\n\n    let range  = { from: 0, refs: [0] }\n    const ranges = [range]\n\n    for (let i = 1; i < this.objects.length; ++i) {\n      const obj = this.objects[i]\n      if (!obj) {\n        if (range) {\n          range = null\n        }\n        continue\n      }\n\n      if (!range) {\n        range = { from: i, refs: [] }\n        ranges.push(range)\n      }\n\n      range.refs.push(obj.offset)\n    }\n\n    ranges.forEach(function(range) {\n      xref += range.from + ' ' + range.refs.length + '\\n'\n\n      range.refs.forEach(function(ref, i) {\n        if (range.from === 0 && i === 0) {\n          xref += '0000000000 65535 f \\n'\n        } else {\n          xref += '0000000000'.substr(ref.toString().length) + ref + ' 00000 n \\n'\n        }\n      })\n    })\n\n    return xref\n  }\n\n  static parse(_, lexer, trial) {\n    const xref = new PDFXref()\n\n    if (lexer.getString(4) !== 'xref') {\n      return this.parseXrefObject(_, lexer, trial)\n    }\n\n    lexer.readString(4) // skip xref\n    lexer.skipSpace(null, trial)\n    lexer.skipEOL(1, trial)\n\n    let start\n    while ((start = lexer.readNumber(true)) !== undefined) {\n      lexer.skipSpace(1)\n      const count = lexer.readNumber()\n      lexer.skipSpace(null, true)\n      lexer.skipEOL(1)\n\n      for (let i = 0, len = 0 + count; i < len; ++i) {\n        const offset = lexer.readNumber()\n        lexer.skipSpace(1)\n        lexer.readNumber() // generation\n        lexer.skipSpace(1)\n        const key = lexer.readString(1)\n        lexer.skipSpace(null, true)\n        lexer.skipEOL(1)\n\n        const id = start + i\n        if (id > 0 && key === 'n') {\n          xref.add(id, {\n            offset: offset,\n          })\n        }\n      }\n    }\n\n    return xref\n  }\n\n  // TODO: this implementation needs to be improved\n  static parseXrefObject(_, lexer, trial) {\n    const xref = new PDFXref()\n\n    let obj\n\n    try {\n      obj = PDFObject.parse(xref, lexer, trial)\n    } catch (_) {\n      throw new Error('Invalid xref: xref expected but not found')\n    }\n\n    let kind = obj.properties.get(\"Type\")\n    if (!kind || kind.name !== \"XRef\") {\n      throw new Error(\"Invalid xref object at \" + lexer.pos)\n    }\n\n    const stream = util.inflate(obj)\n\n    xref.trailer = obj.properties\n\n    const index = obj.properties.get(\"Index\")\n    const start = index ? index[0] : 0\n    const w = obj.properties.get(\"W\")\n    const typeSize = w[0] || 1\n    const offsetSize = w[1] || 2\n    const genSize = w[2] || 1\n    const len = stream.length / (typeSize + offsetSize + genSize)\n    let pos = 0\n    for (let i = 0; i < len; ++i) {\n      const type = readUint(stream, pos, typeSize)\n      pos += typeSize\n      const offset = readUint(stream, pos, offsetSize)\n      pos += offsetSize\n      switch (type) {\n      case 0: // free\n        pos += genSize\n        continue // skip type 0 entries (free entries)\n      case 1: // normal\n        xref.add(start + i, {\n          offset\n        })\n        pos += genSize\n        break\n      case 2: // compressed\n        xref.add(start + i, {\n          compressed: true,\n          id:         offset,\n          ix:         readUint(stream, pos, genSize),\n        })\n        pos += genSize\n        break\n      default:\n        continue\n      }\n    }\n\n    return xref\n  }\n}\n\nfunction readUint(src, pos, size) {\n  let val = 0\n  for (let i = 0; i < size; ++i) {\n  // for (let i = size - 1; i > 0; --i) {\n    val += src[pos + size - i - 1] << (8 * i)\n  }\n  return val\n}\n"]},"metadata":{},"sourceType":"script"}