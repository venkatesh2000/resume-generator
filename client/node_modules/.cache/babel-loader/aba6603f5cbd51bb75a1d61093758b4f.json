{"ast":null,"code":"'use strict';\n\nconst Lexer = require('./lexer');\n\nconst PDF = require('../object');\n\nconst util = require('../util');\n\nclass Parser {\n  // ab ... ArrayBuffer\n  constructor(ab) {\n    this.src = new Uint8Array(util.toArrayBuffer(ab));\n  }\n\n  parse() {\n    let index = lastIndexOf(this.src, 'startxref', 128);\n\n    if (index === -1) {\n      throw new Error('Invalid PDF: startxref not found');\n    }\n\n    index += 'startxref'.length; // skip whitespaces\n\n    while (Lexer.isWhiteSpace(this.src[++index])) {}\n\n    let str = '';\n\n    while (this.src[index] >= 0x30 && this.src[index] <= 0x39) {\n      // between 0 and 9\n      str += String.fromCharCode(this.src[index++]);\n    }\n\n    const startXRef = parseInt(str, 10);\n\n    if (isNaN(startXRef)) {\n      throw new Error('Invalid PDF: startxref is not a number');\n    }\n\n    const lexer = new Lexer(this.src);\n    lexer.shift(startXRef);\n    this.xref = PDF.Xref.parse(null, lexer);\n    this.trailer = this.xref.trailer || PDF.Trailer.parse(this.xref, lexer);\n    let trailer = this.trailer;\n\n    while (trailer.has('Prev')) {\n      const prevTrailerPos = trailer.get('Prev'); // Ignore prev pointers to the document beginning. This is not according to the PDF spec, but\n      // there are PDFs out there doing it anyway.\n\n      if (prevTrailerPos === 0) {\n        break;\n      }\n\n      lexer.pos = trailer.get('Prev');\n      const xref = PDF.Xref.parse(null, lexer);\n\n      for (let i = 0; i < xref.objects.length; ++i) {\n        const obj = xref.objects[i];\n\n        if (obj && !this.xref.objects[i]) {\n          this.xref.objects[i] = obj;\n        }\n      }\n\n      trailer = xref.trailer || PDF.Trailer.parse(xref, lexer);\n    }\n  }\n\n  static addObjectsRecursive(objects, value) {\n    switch (true) {\n      case value instanceof PDF.Reference:\n        if (objects.indexOf(value.object) > -1) {\n          break;\n        }\n\n        objects.push(value.object);\n        Parser.addObjectsRecursive(objects, value.object);\n        break;\n\n      case value instanceof PDF.Object:\n        Parser.addObjectsRecursive(objects, value.properties);\n        Parser.addObjectsRecursive(objects, value.content);\n        break;\n\n      case value instanceof PDF.Dictionary:\n        for (const key in value.dictionary) {\n          if (key === '/Parent') {\n            // ignore parent property to prevent moving above Page objects\n            continue;\n          }\n\n          Parser.addObjectsRecursive(objects, value.dictionary[key]);\n        }\n\n        break;\n\n      case Array.isArray(value):\n        value.forEach(function (item) {\n          Parser.addObjectsRecursive(objects, item);\n        });\n        break;\n    }\n  }\n\n}\n\nmodule.exports = Parser;\n\nfunction lastIndexOf(src, key, step) {\n  if (!step) step = 1024;\n  let pos = src.length,\n      index = -1;\n\n  while (index === -1 && pos > 0) {\n    pos -= step - key.length;\n    index = find(src, key, Math.max(pos, 0), step, true);\n  }\n\n  return index;\n}\n\nfunction find(src, key, pos, limit, backwards) {\n  if (pos + limit > src.length) {\n    limit = src.length - pos;\n  }\n\n  const str = String.fromCharCode.apply(null, src.subarray(pos, pos + limit));\n  let index = backwards ? str.lastIndexOf(key) : str.indexOf(key);\n\n  if (index > -1) {\n    index += pos;\n  }\n\n  return index;\n}","map":{"version":3,"sources":["/mnt/c/Users/Venkatesh/Documents/6th Sem/Web Dev/project/resume-generator/node_modules/pdfjs/lib/parser/parser.js"],"names":["Lexer","require","PDF","util","Parser","constructor","ab","src","Uint8Array","toArrayBuffer","parse","index","lastIndexOf","Error","length","isWhiteSpace","str","String","fromCharCode","startXRef","parseInt","isNaN","lexer","shift","xref","Xref","trailer","Trailer","has","prevTrailerPos","get","pos","i","objects","obj","addObjectsRecursive","value","Reference","indexOf","object","push","Object","properties","content","Dictionary","key","dictionary","Array","isArray","forEach","item","module","exports","step","find","Math","max","limit","backwards","apply","subarray"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Lexer = require('./lexer')\nconst PDF = require('../object')\nconst util = require('../util')\n\nclass Parser {\n  // ab ... ArrayBuffer\n  constructor(ab) {\n    this.src = new Uint8Array(util.toArrayBuffer(ab))\n  }\n\n  parse() {\n    let index = lastIndexOf(this.src, 'startxref', 128)\n    if (index === -1) {\n      throw new Error('Invalid PDF: startxref not found')\n    }\n\n    index += 'startxref'.length\n\n    // skip whitespaces\n    while (Lexer.isWhiteSpace(this.src[++index])) {\n    }\n\n    let str = ''\n    while (this.src[index] >= 0x30 && this.src[index] <= 0x39) { // between 0 and 9\n      str +=  String.fromCharCode(this.src[index++])\n    }\n\n    const startXRef = parseInt(str, 10)\n\n    if (isNaN(startXRef)) {\n      throw new Error('Invalid PDF: startxref is not a number')\n    }\n\n    const lexer = new Lexer(this.src)\n    lexer.shift(startXRef)\n\n    this.xref    = PDF.Xref.parse(null, lexer)\n    this.trailer = this.xref.trailer || PDF.Trailer.parse(this.xref, lexer)\n\n    let trailer = this.trailer\n    while (trailer.has('Prev')) {\n      const prevTrailerPos = trailer.get('Prev');\n      // Ignore prev pointers to the document beginning. This is not according to the PDF spec, but\n      // there are PDFs out there doing it anyway.\n      if (prevTrailerPos === 0) {\n        break;\n      }\n\n      lexer.pos = trailer.get('Prev')\n      const xref = PDF.Xref.parse(null, lexer)\n\n      for (let i = 0; i < xref.objects.length; ++i) {\n        const obj = xref.objects[i]\n        if (obj && !this.xref.objects[i]) {\n          this.xref.objects[i] = obj\n        }\n      }\n\n      trailer = xref.trailer || PDF.Trailer.parse(xref, lexer)\n    }\n  }\n\n  static addObjectsRecursive(objects, value) {\n    switch (true) {\n      case value instanceof PDF.Reference:\n        if (objects.indexOf(value.object) > -1) {\n          break\n        }\n        objects.push(value.object)\n        Parser.addObjectsRecursive(objects, value.object)\n        break\n      case value instanceof PDF.Object:\n        Parser.addObjectsRecursive(objects, value.properties)\n        Parser.addObjectsRecursive(objects, value.content)\n        break\n      case value instanceof PDF.Dictionary:\n        for (const key in value.dictionary) {\n          if (key === '/Parent') {\n            // ignore parent property to prevent moving above Page objects\n            continue\n          }\n          Parser.addObjectsRecursive(objects, value.dictionary[key])\n        }\n        break\n      case Array.isArray(value):\n        value.forEach(function(item) {\n          Parser.addObjectsRecursive(objects, item)\n        })\n        break\n    }\n  }\n}\n\nmodule.exports = Parser\n\nfunction lastIndexOf(src, key, step) {\n  if (!step) step = 1024\n  let pos = src.length, index = -1\n\n  while (index === -1 && pos > 0) {\n    pos -= step - key.length\n    index = find(src, key, Math.max(pos, 0), step, true)\n  }\n\n  return index\n}\n\nfunction find(src, key, pos, limit, backwards) {\n  if (pos + limit > src.length) {\n    limit = src.length - pos\n  }\n\n  const str = String.fromCharCode.apply(null, src.subarray(pos, pos + limit))\n  let index = backwards ? str.lastIndexOf(key) : str.indexOf(key)\n  if (index > -1) {\n    index += pos\n  }\n  return index\n}\n"]},"metadata":{},"sourceType":"script"}