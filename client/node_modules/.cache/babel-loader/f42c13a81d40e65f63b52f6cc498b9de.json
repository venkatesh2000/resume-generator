{"ast":null,"code":"'use strict';\n\nclass Lexer {\n  constructor(buf, outer) {\n    this.buf = buf;\n    this.pos = 0;\n    this.objects = Object.create(null);\n    this._outer = outer;\n    this.state = outer ? outer.state : {};\n  }\n\n  get outer() {\n    return this._outer || this;\n  }\n\n  read(len) {\n    const buf = this.buf.subarray(this.pos, this.pos + len);\n    this.pos += len;\n    return buf;\n  }\n\n  getString(len) {\n    return String.fromCharCode.apply(null, this.buf.subarray(this.pos, this.pos + len));\n  }\n\n  readString(len) {\n    const str = this.getString(len);\n    this.pos += len;\n    return str;\n  }\n\n  skipEOL(len, trial) {\n    const before = this.pos;\n    let done = false;\n    let count = 0;\n\n    while (!done && (!len || count < len)) {\n      switch (this.buf[this.pos]) {\n        case 0x0d:\n          // CR\n          if (this.buf[this.pos + 1] === 0x0a) {\n            // CR LF\n            this.pos++;\n          }\n\n        // falls through\n\n        case 0x0a:\n          // LF\n          this.pos++;\n          count++;\n          break;\n\n        default:\n          done = true;\n          break;\n      }\n    }\n\n    if (!count || len && count < len) {\n      if (!trial) {\n        this._error('EOL expected but not found');\n      }\n\n      this.pos = before;\n      return false;\n    }\n\n    return true;\n  }\n\n  skipComments(trial) {\n    if (this.getString(1) !== '%') {\n      return false;\n    }\n\n    let pos = this.pos;\n\n    while (this.buf[pos] !== 0x0A) {\n      pos++;\n    }\n\n    if (!trial) {\n      this.pos = pos;\n    }\n\n    return true;\n  }\n\n  skipWhitespace(len, trial) {\n    const before = this.pos;\n    let done = false;\n    let count = 0;\n\n    while (!done && (!len || count < len)) {\n      // skip comments\n      if (this.buf[this.pos] === 0x25\n      /* % */\n      ) {\n          while (this.buf[this.pos] !== 0x0A) {\n            this.pos++;\n          }\n        }\n\n      if (Lexer.isWhiteSpace(this.buf[this.pos])) {\n        this.pos++;\n        count++;\n      } else {\n        done = true;\n      }\n    }\n\n    if (!count || len && count < len) {\n      if (!trial) {\n        this._error('Whitespace expected but not found');\n      }\n\n      this.pos = before;\n      return false;\n    }\n\n    return true;\n  }\n\n  skipSpace(len, trial) {\n    const before = this.pos;\n    let done = false;\n    let count = 0;\n\n    while (!done && (!len || count < len)) {\n      if (this.buf[this.pos] === 0x20) {\n        this.pos++;\n        count++;\n      } else {\n        done = true;\n      }\n    }\n\n    if (len > 0 && !count || len && count < len) {\n      if (!trial) {\n        this._error('Space expected but not found');\n      }\n\n      this.pos = before;\n      return false;\n    }\n\n    return true;\n  }\n\n  shift(offset) {\n    this.pos += offset;\n  }\n\n  _nextCharCode() {\n    return this.buf[this.pos++];\n  }\n\n  _nextChar() {\n    return String.fromCharCode(this.buf[this.pos++]);\n  }\n\n  _error(err) {\n    throw new Error(err);\n  }\n\n  _warning(warning) {\n    console.warn(warning);\n  } // e.g. 123 43445 +17 −98 0 34.5 −3.62 +123.6 4. −.002 0.0\n\n\n  readNumber(trial) {\n    const before = this.pos;\n\n    let c = this._nextCharCode();\n\n    let sign = 1;\n    let isFloat = false;\n    let str = '';\n\n    switch (true) {\n      case c === 0x2b:\n        // '+'\n        break;\n\n      case c === 0x2d:\n        // '-'\n        sign = -1;\n        break;\n\n      case c === 0x2e:\n        // '.'\n        isFloat = true;\n        str = '0.';\n        break;\n\n      case c < 0x30 || c > 0x39:\n        // not a number\n        if (!trial) {\n          this._error('Invalid number at ' + this.pos + ': ' + String.fromCharCode(c) + ' (code: ' + c + ')');\n        }\n\n        this.pos = before;\n        return undefined;\n\n      default:\n        str += String.fromCharCode(c);\n        break;\n    }\n\n    let done = false;\n\n    while (!done && (c = this._nextCharCode()) >= 0) {\n      switch (true) {\n        case c === 0x2e:\n          // '.'\n          if (isFloat) {\n            done = true;\n          } else {\n            isFloat = true;\n            str += '.';\n          }\n\n          break;\n\n        case c >= 0x30 && c <= 0x39:\n          // 0 - 9\n          str += String.fromCharCode(c);\n          break;\n\n        default:\n          done = true;\n          break;\n      }\n    }\n\n    this.pos--;\n    const nr = isFloat ? parseFloat(str, 10) : parseInt(str, 10);\n    return nr * sign;\n  }\n\n  static isWhiteSpace(c) {\n    return c === 0x00 || // NULL\n    c === 0x09 || // TAB\n    c === 0x0A || // LF\n    c === 0x0C || // FF\n    c === 0x0D || // CR\n    c === 0x20 // SP\n    ;\n  }\n\n}\n\nmodule.exports = Lexer;","map":{"version":3,"sources":["/mnt/c/Users/Venkatesh/Documents/6th Sem/Web Dev/project/resume-generator/node_modules/pdfjs/lib/parser/lexer.js"],"names":["Lexer","constructor","buf","outer","pos","objects","Object","create","_outer","state","read","len","subarray","getString","String","fromCharCode","apply","readString","str","skipEOL","trial","before","done","count","_error","skipComments","skipWhitespace","isWhiteSpace","skipSpace","shift","offset","_nextCharCode","_nextChar","err","Error","_warning","warning","console","warn","readNumber","c","sign","isFloat","undefined","nr","parseFloat","parseInt","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nclass Lexer {\n  constructor(buf, outer) {\n    this.buf = buf\n    this.pos = 0\n    this.objects = Object.create(null)\n    this._outer = outer\n    this.state = outer ? outer.state : {}\n  }\n\n  get outer() {\n    return this._outer || this\n  }\n\n  read(len) {\n    const buf = this.buf.subarray(this.pos, this.pos + len)\n    this.pos += len\n    return buf\n  }\n\n  getString(len) {\n    return String.fromCharCode.apply(null, this.buf.subarray(this.pos, this.pos + len))\n  }\n\n  readString(len) {\n    const str = this.getString(len)\n    this.pos += len\n    return str\n  }\n\n  skipEOL(len, trial) {\n    const before = this.pos\n\n    let done  = false\n    let count = 0\n    while (!done && (!len || count < len)) {\n      switch (this.buf[this.pos]) {\n        case 0x0d: // CR\n          if (this.buf[this.pos + 1] === 0x0a) { // CR LF\n            this.pos++\n          }\n          // falls through\n        case 0x0a: // LF\n          this.pos++\n          count++\n          break\n        default:\n          done = true\n          break\n      }\n    }\n\n    if (!count || (len && count < len)) {\n      if (!trial) {\n        this._error('EOL expected but not found')\n      }\n      this.pos = before\n      return false\n    }\n\n    return true\n  }\n\n  skipComments(trial) {\n    if (this.getString(1) !== '%') {\n      return false\n    }\n\n    let pos = this.pos;\n    while (this.buf[pos] !== 0x0A) {\n      pos++;\n    }\n\n    if (!trial) {\n      this.pos = pos;\n    }\n\n    return true\n  }\n\n  skipWhitespace(len, trial) {\n    const before = this.pos\n\n    let done  = false\n    let count = 0\n    while (!done && (!len || count < len)) {\n      // skip comments\n      if (this.buf[this.pos] === 0x25 /* % */) {\n        while (this.buf[this.pos] !== 0x0A) {\n          this.pos++;\n        }\n      }\n\n      if (Lexer.isWhiteSpace(this.buf[this.pos])) {\n        this.pos++\n        count++\n      } else {\n        done = true\n      }\n    }\n\n    if (!count || (len && count < len)) {\n      if (!trial) {\n        this._error('Whitespace expected but not found')\n      }\n      this.pos = before\n      return false\n    }\n\n    return true\n  }\n\n  skipSpace(len, trial) {\n    const before = this.pos\n\n    let done  = false\n    let count = 0\n    while (!done && (!len || count < len)) {\n      if (this.buf[this.pos] === 0x20) {\n        this.pos++\n        count++\n      } else {\n        done = true\n      }\n    }\n\n    if ((len > 0 && !count) || (len && count < len)) {\n      if (!trial) {\n        this._error('Space expected but not found')\n      }\n      this.pos = before\n      return false\n    }\n\n    return true\n  }\n\n  shift(offset) {\n    this.pos += offset\n  }\n\n  _nextCharCode() {\n    return this.buf[this.pos++]\n  }\n\n  _nextChar() {\n    return String.fromCharCode(this.buf[this.pos++])\n  }\n\n  _error(err) {\n    throw new Error(err)\n  }\n\n  _warning(warning) {\n    console.warn(warning)\n  }\n\n  // e.g. 123 43445 +17 −98 0 34.5 −3.62 +123.6 4. −.002 0.0\n  readNumber(trial) {\n    const before = this.pos\n\n    let c = this._nextCharCode()\n    let sign = 1\n    let isFloat = false\n    let str = ''\n\n    switch (true) {\n      case c === 0x2b: // '+'\n        break\n      case c === 0x2d: // '-'\n        sign = -1\n        break\n      case c === 0x2e: // '.'\n        isFloat = true\n        str = '0.'\n        break\n      case c < 0x30 || c > 0x39: // not a number\n        if (!trial) {\n          this._error('Invalid number at ' + this.pos + ': ' + String.fromCharCode(c) + ' (code: ' + c + ')')\n        }\n        this.pos = before\n        return undefined\n      default:\n        str += String.fromCharCode(c)\n        break\n    }\n\n    let done = false\n    while (!done && (c = this._nextCharCode()) >= 0) {\n      switch (true) {\n        case c === 0x2e: // '.'\n          if (isFloat) {\n            done = true\n          } else {\n            isFloat = true\n            str += '.'\n          }\n          break\n        case c >= 0x30 && c <= 0x39: // 0 - 9\n          str += String.fromCharCode(c)\n          break\n        default:\n          done = true\n          break\n      }\n    }\n\n    this.pos--\n\n    const nr = isFloat ? parseFloat(str, 10) : parseInt(str, 10)\n    return nr * sign\n  }\n\n  static isWhiteSpace(c) {\n    return (\n      c === 0x00 || // NULL\n      c === 0x09 || // TAB\n      c === 0x0A || // LF\n      c === 0x0C || // FF\n      c === 0x0D || // CR\n      c === 0x20    // SP\n    )\n  }\n}\n\nmodule.exports = Lexer\n"]},"metadata":{},"sourceType":"script"}