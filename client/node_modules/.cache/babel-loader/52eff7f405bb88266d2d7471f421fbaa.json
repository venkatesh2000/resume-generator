{"ast":null,"code":"'use strict';\n\nconst Fragment = require('./fragment');\n\nconst util = require('./util');\n\nconst ops = require('./ops');\n\nconst Cell = require('./cell');\n\nmodule.exports = class Row {\n  constructor(doc, parent, opts) {\n    Fragment.prototype._init.call(this, doc, parent);\n\n    this.opts = opts; // use an own queue for pending operations\n\n    this._pending = []; // keep track of the cells that have already been ended;\n    // this is necessary to be able to still draw their background and finalize their rendering\n    // once all cells are ended (scenario where not all cells span the same amount of pages)\n\n    this._endedCells = []; // keep a count of not ended cells to adjust the rotation of cells on page breaks properly\n\n    this._columns = 0; // when a page break occures inside a cell, the cells are rotated before an actual page\n    // break is rendered; i.e., all cells of the row are rendered horizontally\n\n    this._rotated = 0; // this is used to keep track of the starting y of the row to reset the cursor's y to\n    // this value for each cell (since they are horizontally aligned)\n\n    this._y = 0; // on each page the row is rendered on, the row keeps track of the maximal y (or minimum\n    // in terms of PDF, because y 0 is on the bottom) a cell is rendered to, to be able to align\n    // the backgrounds of all cells to the same height\n\n    this._endY = null;\n    this._widths = [];\n    this._topBorderWidth = 0;\n    this._topBorderColor = 0x000000;\n    this._bottomBorderWidth = 0;\n    this._bottomBorderColor = 0x000000;\n    this._borderVerticalWidths = [];\n    this._borderVerticalColors = [];\n    this._minHeight = opts.minHeight || 0;\n    this._hasTopBorder = false;\n    this._insideBreak = false;\n    this._startRendering = null;\n  } /// private API\n\n\n  async _pageBreak(level, insideBreak) {\n    this._insideBreak = insideBreak; // the pending queue looks as follows: [ [cell1], [cell2], ..., [celln], endRow]\n    // the currently rendered cell is at the head of the queue and therefore removed and\n    // re-inserted at the second last position\n\n    this._pending.splice(this._pending.length - 2, 0, this._pending.shift()); // test whether we have rotated all cells of the row\n\n\n    if (this._rotated < this._columns - 1) {\n      this._rotated++; // move to the next cell\n\n      this._nextColumn();\n    } else {\n      // execute the pageBreak (rendering background, trigger retrospective page breaks, ...) of all\n      // already ended cells manually\n      for (const cell of this._endedCells) {\n        this._cursor.y = cell._cursor.bottom;\n        await cell._pageBreak(level - 1, insideBreak); // pageBreak may add new callbacks to the cell's pending queue, which is however not anymore\n        // contained in the document's queue, therefor add these callbacks to the row's queue\n\n        while (cell._pending.length) {\n          this._pending.unshift(cell._pending.shift());\n        }\n      }\n\n      await this._drawBorders(true, insideBreak); // reset the rotation\n\n      this._rotated = 0; // execute an actual page break\n\n      await this._parent._pageBreak(level + 1, insideBreak); // store starting y to be able to align all cells horizontally\n\n      this._y = this._cursor.y;\n      this._endY = null;\n    }\n  }\n\n  _nextColumn() {\n    // reset the current y back to the row start to align all cells horizontally\n    this._cursor.y = this._y;\n  }\n\n  async _start() {\n    if (this._minHeight > 0 && !this._parent._cursor.doesFit(this._minHeight)) {\n      await this._parent._pageBreak(1);\n    } // save start y of the row to be able to align all cells horizontally\n\n\n    this._y = this._cursor.y; // block execution until the row knows about all its cells, otherwise it is possible that the\n    // rendering scheduler (_pending) removes this._pending before the cell's end got called\n\n    if (!this._ended) {\n      await new Promise(resolve => {\n        this._startRendering = resolve;\n      });\n    }\n  }\n\n  async _end() {\n    // the actual end logic of cells has been postponed until here where it is called manually\n    for (const cell of this._endedCells) {\n      this._cursor.y = this._endY + cell.paddingBottom;\n      await Cell.prototype._end.call(cell);\n    }\n\n    await this._drawBorders(false); // reset cursor\n\n    this._cursor.x = this._cursor.startX;\n    this._cursor.y = this._endY;\n  }\n\n  _begin(ctx) {\n    Fragment.prototype._begin.call(this, ctx);\n  }\n\n  async _drawBorders(isPageBreak, isInsideBreak) {\n    // detect a retrospective page break and not render borders in this case\n    if (isPageBreak && !isInsideBreak) {\n      this._hasTopBorder = true;\n      return;\n    } // draw border\n\n\n    let hasBorder = false;\n    let chunk = ops.q(); // save graphics state\n\n    const y1 = this._y;\n    const y2 = isPageBreak ? this._cursor.bottom : this._endY;\n    let left = this._cursor.startX;\n    let borderWidth = 0;\n    let borderColor = null;\n\n    if (this._borderVerticalWidths) {\n      for (let i = 0, len = this._borderVerticalWidths.length; i < len; ++i) {\n        // line width\n        const bw = this._borderVerticalWidths[i];\n\n        if (bw > 0) {\n          if (borderWidth !== bw) {\n            chunk += ops.w(bw);\n            borderWidth = bw;\n          } // stroking color\n\n\n          const bc = this._borderVerticalColors[i];\n\n          if (!borderColor || !util.rgbEqual(borderColor, bc)) {\n            chunk += ops.SC(bc[0], bc[1], bc[2]);\n            borderColor = bc;\n          } // fill path\n\n\n          let x = left;\n\n          if (i === 0) {\n            x += bw / 2;\n          } else if (i === len - 1) {\n            x -= bw / 2;\n          }\n\n          chunk += ops.S(x, y1, 'm', x, y2, 'l');\n        }\n\n        left += this._widths[i];\n      }\n\n      hasBorder = true;\n    }\n\n    const totalWidth = this._widths.reduce((lhs, rhs) => lhs + rhs, 0);\n\n    const x1 = this._cursor.startX;\n    const x2 = x1 + totalWidth;\n\n    if (this._hasTopBorder && this._topBorderWidth > 0) {\n      this._hasTopBorder = false; // line width\n\n      if (borderWidth !== this._topBorderWidth) {\n        chunk += ops.w(this._topBorderWidth);\n        borderWidth = this._topBorderWidth;\n      } // stroking color\n\n\n      if (!borderColor || !util.rgbEqual(borderColor, this._topBorderColor)) {\n        chunk += ops.SC(this._topBorderColor[0], this._topBorderColor[1], this._topBorderColor[2]);\n        borderColor = this._topBorderColor;\n      } // fill path\n\n\n      const y = y1 - this._topBorderWidth / 2;\n      chunk += ops.S(x1, y, 'm', x2, y, 'l');\n      hasBorder = true;\n    }\n\n    if (!isPageBreak && this._bottomBorderWidth > 0) {\n      // line width\n      if (borderWidth !== this._bottomBorderWidth) {\n        chunk += ops.w(this._bottomBorderWidth);\n        borderWidth = this._bottomBorderWidth;\n      } // stroking color\n\n\n      if (!borderColor || !util.rgbEqual(borderColor, this._bottomBorderColor)) {\n        chunk += ops.SC(this._bottomBorderColor[0], this._bottomBorderColor[1], this._bottomBorderColor[2]);\n        borderColor = this._bottomBorderColor;\n      } // fill path\n\n\n      const y = y2 + this._bottomBorderWidth / 2;\n      chunk += ops.S(x1, y, 'm', x2, y, 'l');\n      hasBorder = true;\n    }\n\n    if (hasBorder) {\n      chunk += ops.Q(); // restore graphics state\n\n      await this._doc._startContentObject(null, true);\n      await this._doc._write(chunk);\n    }\n  } /// public API\n\n\n  end() {\n    if (this._columns !== this._widths.length) {\n      if (this._columns > this._widths.length) {\n        throw new Error(`Row has ${this.columns} cells but only ${this._widths.length} columns`);\n      } // fill missing columns with empty cells\n\n\n      for (let i = this.columns; i < this._widths.length; ++i) {\n        this.cell();\n      }\n    }\n\n    if (this._startRendering) {\n      this._startRendering();\n    }\n\n    return Fragment.prototype.end.call(this);\n  }\n\n  cell(text, opts) {\n    // normalize arguments\n    if (text !== null && typeof text === 'object') {\n      opts = text;\n      text = undefined;\n    }\n\n    if (!opts || typeof opts !== 'object') {\n      opts = {};\n    }\n\n    opts = Object.assign({}, this.opts, opts); // create cell and set cell's width according to row options\n\n    const column = this._columns++;\n\n    if (!(column in this._widths)) {\n      throw new Error('row columns already exceeded, cannot create another cell');\n    }\n\n    if (opts.colspan > 1) {\n      for (let i = column + 1, len = column + opts.colspan; i < len; ++i) {\n        if (!(i in this._widths)) {\n          throw new Error('row columns already exceeded, colspan to big');\n        }\n\n        this._widths[column] += this._widths[i];\n      }\n\n      this._widths.splice(column + 1, opts.colspan - 1);\n\n      if (this._borderVerticalWidths) {\n        this._borderVerticalWidths.splice(column + 1, opts.colspan - 1);\n      }\n    }\n\n    if (opts.minHeight > this._minHeight) {\n      this._minHeight = opts.minHeight;\n    } // adjust cell padding to add enough space for borders\n\n\n    if (this._borderVerticalWidths) {\n      const borderWidthLeft = this._borderVerticalWidths[column];\n      const borderWidthRight = this._borderVerticalWidths[column + 1];\n\n      if (borderWidthLeft > 0) {\n        if (column === 0) {\n          // is first\n          opts.borderLeftWidth = borderWidthLeft;\n        } else {\n          opts.borderLeftWidth = borderWidthLeft / 2;\n        }\n      }\n\n      if (borderWidthRight > 0) {\n        if (column === this._widths.length - 1) {\n          // is last\n          opts.borderRightWidth = borderWidthRight;\n        } else {\n          opts.borderRightWidth = borderWidthRight / 2;\n        }\n      }\n    }\n\n    if (this._hasTopBorder && this._topBorderWidth > 0) {\n      opts.borderTopWidth = this._topBorderWidth;\n    }\n\n    if (this._bottomBorderWidth > 0) {\n      opts.borderBottomWidth = this._bottomBorderWidth;\n    }\n\n    const ctx = new Cell(this._doc, this, Object.assign({}, opts, {\n      width: this._widths[column]\n    }));\n    ctx._drawBorders = false;\n\n    this._begin(ctx); // move the cell to the right by the width of each previous cell\n\n\n    for (let i = 0; i < column; ++i) {\n      ctx._cursor.startX += this._widths[i] || 0;\n    }\n\n    ctx._pending.push(() => ctx._start()); // override cell's end logic, which is also postponed until the row ends\n\n\n    ctx._end = endCell.bind(ctx, this);\n\n    this._pending.push(ctx._pending);\n\n    if (typeof text === 'string' && text.length > 0) {\n      ctx.text(text, opts);\n    }\n\n    return ctx;\n  }\n\n};\n\nasync function endCell(row) {\n  // apply bottom padding\n  this._cursor.y -= this.paddingBottom;\n  const height = this._startY - this._cursor.y;\n\n  if (height < this.opts.minHeight) {\n    this._cursor.y -= this.opts.minHeight - height;\n  } // decrease the counter of active cells\n\n\n  row._columns--; // reset the parent property, to prevent endless recursion when the pageBreak handler of the\n  // cell is called later on\n\n  this._parent = null; // keep track of the ended cell\n\n  row._endedCells.push(this); // if, last row has been ended, trigger page break manually to continue with other cells on\n  // the next page\n\n\n  if (row._columns > 0 && row._rotated === row._columns) {\n    // TODO: level hardcoded?\n    await row._pageBreak(2, row._insideBreak);\n  } // keep track of the ending y which is nearest to the page end\n\n\n  if (row._endY === null || this._cursor.y < row._endY) {\n    row._endY = this._cursor.y;\n  }\n\n  this._endLayerRef = this._doc._currentContent; // move to the next cell\n\n  row._nextColumn();\n}","map":{"version":3,"sources":["/mnt/c/Users/Venkatesh/Documents/6th Sem/Web Dev/project/resume-generator/node_modules/pdfjs/lib/row.js"],"names":["Fragment","require","util","ops","Cell","module","exports","Row","constructor","doc","parent","opts","prototype","_init","call","_pending","_endedCells","_columns","_rotated","_y","_endY","_widths","_topBorderWidth","_topBorderColor","_bottomBorderWidth","_bottomBorderColor","_borderVerticalWidths","_borderVerticalColors","_minHeight","minHeight","_hasTopBorder","_insideBreak","_startRendering","_pageBreak","level","insideBreak","splice","length","shift","_nextColumn","cell","_cursor","y","bottom","unshift","_drawBorders","_parent","_start","doesFit","_ended","Promise","resolve","_end","paddingBottom","x","startX","_begin","ctx","isPageBreak","isInsideBreak","hasBorder","chunk","q","y1","y2","left","borderWidth","borderColor","i","len","bw","w","bc","rgbEqual","SC","S","totalWidth","reduce","lhs","rhs","x1","x2","Q","_doc","_startContentObject","_write","end","Error","columns","text","undefined","Object","assign","column","colspan","borderWidthLeft","borderWidthRight","borderLeftWidth","borderRightWidth","borderTopWidth","borderBottomWidth","width","push","endCell","bind","row","height","_startY","_endLayerRef","_currentContent"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Fragment = require('./fragment')\nconst util = require('./util')\nconst ops = require('./ops')\nconst Cell = require('./cell')\n\nmodule.exports = class Row {\n  constructor(doc, parent, opts) {\n    Fragment.prototype._init.call(this, doc, parent)\n\n    this.opts = opts\n\n    // use an own queue for pending operations\n    this._pending = []\n\n    // keep track of the cells that have already been ended;\n    // this is necessary to be able to still draw their background and finalize their rendering\n    // once all cells are ended (scenario where not all cells span the same amount of pages)\n    this._endedCells = []\n\n    // keep a count of not ended cells to adjust the rotation of cells on page breaks properly\n    this._columns = 0\n\n    // when a page break occures inside a cell, the cells are rotated before an actual page\n    // break is rendered; i.e., all cells of the row are rendered horizontally\n    this._rotated = 0\n\n    // this is used to keep track of the starting y of the row to reset the cursor's y to\n    // this value for each cell (since they are horizontally aligned)\n    this._y = 0\n\n    // on each page the row is rendered on, the row keeps track of the maximal y (or minimum\n    // in terms of PDF, because y 0 is on the bottom) a cell is rendered to, to be able to align\n    // the backgrounds of all cells to the same height\n    this._endY = null\n\n    this._widths = []\n    this._topBorderWidth = 0\n    this._topBorderColor = 0x000000\n    this._bottomBorderWidth = 0\n    this._bottomBorderColor = 0x000000\n    this._borderVerticalWidths = []\n    this._borderVerticalColors = []\n    this._minHeight = opts.minHeight || 0\n\n    this._hasTopBorder = false\n    this._insideBreak = false\n    this._startRendering = null\n  }\n\n  /// private API\n\n  async _pageBreak(level, insideBreak) {\n    this._insideBreak = insideBreak\n\n    // the pending queue looks as follows: [ [cell1], [cell2], ..., [celln], endRow]\n    // the currently rendered cell is at the head of the queue and therefore removed and\n    // re-inserted at the second last position\n    this._pending.splice(this._pending.length - 2, 0 , this._pending.shift())\n\n    // test whether we have rotated all cells of the row\n    if (this._rotated < this._columns - 1) {\n      this._rotated++\n\n      // move to the next cell\n      this._nextColumn()\n    } else {\n      // execute the pageBreak (rendering background, trigger retrospective page breaks, ...) of all\n      // already ended cells manually\n      for (const cell of this._endedCells) {\n        this._cursor.y = cell._cursor.bottom\n        await cell._pageBreak(level - 1, insideBreak)\n\n        // pageBreak may add new callbacks to the cell's pending queue, which is however not anymore\n        // contained in the document's queue, therefor add these callbacks to the row's queue\n        while (cell._pending.length) {\n          this._pending.unshift(cell._pending.shift())\n        }\n      }\n\n      await this._drawBorders(true, insideBreak)\n\n      // reset the rotation\n      this._rotated = 0\n\n      // execute an actual page break\n      await this._parent._pageBreak(level + 1, insideBreak)\n\n      // store starting y to be able to align all cells horizontally\n      this._y = this._cursor.y\n\n      this._endY = null\n    }\n  }\n\n  _nextColumn() {\n    // reset the current y back to the row start to align all cells horizontally\n    this._cursor.y = this._y\n  }\n\n  async _start() {\n    if (this._minHeight > 0 && !this._parent._cursor.doesFit(this._minHeight)) {\n      await this._parent._pageBreak(1)\n    }\n\n    // save start y of the row to be able to align all cells horizontally\n    this._y = this._cursor.y\n\n    // block execution until the row knows about all its cells, otherwise it is possible that the\n    // rendering scheduler (_pending) removes this._pending before the cell's end got called\n    if (!this._ended) {\n      await new Promise(resolve => {this._startRendering = resolve})\n    }\n  }\n\n  async _end() {\n    // the actual end logic of cells has been postponed until here where it is called manually\n    for (const cell of this._endedCells) {\n      this._cursor.y = this._endY + cell.paddingBottom\n      await Cell.prototype._end.call(cell)\n    }\n\n    await this._drawBorders(false)\n\n    // reset cursor\n    this._cursor.x = this._cursor.startX\n    this._cursor.y = this._endY\n  }\n\n  _begin(ctx) {\n    Fragment.prototype._begin.call(this, ctx)\n  }\n\n  async _drawBorders(isPageBreak, isInsideBreak) {\n    // detect a retrospective page break and not render borders in this case\n    if (isPageBreak && !isInsideBreak) {\n      this._hasTopBorder = true\n      return\n    }\n\n    // draw border\n    let hasBorder = false\n    let chunk = ops.q() // save graphics state\n\n    const y1 = this._y\n    const y2 = isPageBreak ? this._cursor.bottom : this._endY\n    let left = this._cursor.startX\n    let borderWidth = 0\n    let borderColor = null\n\n    if (this._borderVerticalWidths) {\n      for (let i = 0, len = this._borderVerticalWidths.length; i < len; ++i) {\n        // line width\n        const bw = this._borderVerticalWidths[i]\n        if (bw > 0) {\n          if (borderWidth !== bw) {\n            chunk += ops.w(bw)\n            borderWidth = bw\n          }\n\n          // stroking color\n          const bc = this._borderVerticalColors[i]\n          if (!borderColor || !util.rgbEqual(borderColor, bc)) {\n            chunk += ops.SC(bc[0], bc[1], bc[2])\n            borderColor = bc\n          }\n\n          // fill path\n          let x = left\n          if (i === 0) {\n            x += bw / 2\n          } else if (i === len - 1) {\n            x -= bw / 2\n          }\n\n          chunk += ops.S(x, y1, 'm', x, y2, 'l')\n        }\n\n        left += this._widths[i]\n      }\n\n      hasBorder = true\n    }\n\n    const totalWidth = this._widths.reduce((lhs, rhs) => lhs + rhs, 0)\n    const x1 = this._cursor.startX\n    const x2 = x1 + totalWidth\n\n    if (this._hasTopBorder && this._topBorderWidth > 0) {\n      this._hasTopBorder = false\n\n      // line width\n      if (borderWidth !== this._topBorderWidth) {\n        chunk += ops.w(this._topBorderWidth)\n        borderWidth = this._topBorderWidth\n      }\n\n      // stroking color\n      if (!borderColor || !util.rgbEqual(borderColor, this._topBorderColor)) {\n        chunk += ops.SC(this._topBorderColor[0], this._topBorderColor[1], this._topBorderColor[2])\n        borderColor = this._topBorderColor\n      }\n\n      // fill path\n      const y = y1 - this._topBorderWidth / 2\n      chunk += ops.S(x1, y, 'm', x2, y, 'l')\n\n      hasBorder = true\n    }\n\n    if (!isPageBreak && this._bottomBorderWidth > 0) {\n      // line width\n      if (borderWidth !== this._bottomBorderWidth) {\n        chunk += ops.w(this._bottomBorderWidth)\n        borderWidth = this._bottomBorderWidth\n      }\n\n      // stroking color\n      if (!borderColor || !util.rgbEqual(borderColor, this._bottomBorderColor)) {\n        chunk += ops.SC(this._bottomBorderColor[0], this._bottomBorderColor[1], this._bottomBorderColor[2])\n        borderColor = this._bottomBorderColor\n      }\n\n      // fill path\n      const y = y2 + this._bottomBorderWidth / 2\n      chunk += ops.S(x1, y, 'm', x2, y, 'l')\n\n      hasBorder = true\n    }\n\n    if (hasBorder) {\n      chunk += ops.Q() // restore graphics state\n\n      await this._doc._startContentObject(null, true)\n      await this._doc._write(chunk)\n    }\n  }\n\n  /// public API\n\n  end() {\n    if (this._columns !== this._widths.length) {\n      if (this._columns > this._widths.length) {\n        throw new Error(`Row has ${this.columns} cells but only ${this._widths.length} columns`)\n      }\n\n      // fill missing columns with empty cells\n      for (let i = this.columns; i < this._widths.length; ++i) {\n        this.cell()\n      }\n    }\n\n    if (this._startRendering) {\n      this._startRendering()\n    }\n    return Fragment.prototype.end.call(this)\n  }\n\n  cell(text, opts) {\n    // normalize arguments\n    if (text !== null && typeof text === 'object') {\n      opts = text\n      text = undefined\n    }\n    if (!opts || typeof opts !== 'object') {\n      opts = {}\n    }\n\n    opts = Object.assign({}, this.opts, opts)\n\n    // create cell and set cell's width according to row options\n    const column = this._columns++\n    if (!(column in this._widths)) {\n      throw new Error('row columns already exceeded, cannot create another cell')\n    }\n\n    if (opts.colspan > 1) {\n      for (let i = column + 1, len = column + opts.colspan; i < len; ++i) {\n        if (!(i in this._widths)) {\n          throw new Error('row columns already exceeded, colspan to big')\n        }\n\n        this._widths[column] += this._widths[i]\n      }\n\n      this._widths.splice(column + 1, opts.colspan - 1)\n\n      if (this._borderVerticalWidths) {\n        this._borderVerticalWidths.splice(column + 1, opts.colspan - 1)\n      }\n    }\n\n    if (opts.minHeight > this._minHeight) {\n      this._minHeight = opts.minHeight\n    }\n\n    // adjust cell padding to add enough space for borders\n    if (this._borderVerticalWidths) {\n      const borderWidthLeft = this._borderVerticalWidths[column]\n      const borderWidthRight = this._borderVerticalWidths[column + 1]\n\n      if (borderWidthLeft > 0) {\n        if (column === 0) { // is first\n          opts.borderLeftWidth = borderWidthLeft\n        } else {\n          opts.borderLeftWidth = borderWidthLeft / 2\n        }\n      }\n\n      if (borderWidthRight > 0) {\n        if (column === this._widths.length - 1) { // is last\n          opts.borderRightWidth = borderWidthRight\n        } else {\n          opts.borderRightWidth = borderWidthRight / 2\n        }\n      }\n    }\n\n    if (this._hasTopBorder && this._topBorderWidth > 0) {\n      opts.borderTopWidth = this._topBorderWidth\n    }\n\n    if (this._bottomBorderWidth > 0) {\n      opts.borderBottomWidth = this._bottomBorderWidth\n    }\n\n    const ctx = new Cell(this._doc, this, Object.assign({}, opts, {\n      width: this._widths[column]\n    }))\n    ctx._drawBorders = false\n\n    this._begin(ctx)\n\n    // move the cell to the right by the width of each previous cell\n    for (let i = 0; i < column; ++i) {\n      ctx._cursor.startX += this._widths[i] || 0\n    }\n    ctx._pending.push(() => ctx._start())\n\n    // override cell's end logic, which is also postponed until the row ends\n    ctx._end = endCell.bind(ctx, this)\n\n    this._pending.push(ctx._pending)\n\n    if (typeof text === 'string' && text.length > 0) {\n      ctx.text(text, opts)\n    }\n\n    return ctx\n  }\n}\n\nasync function endCell(row) {\n  // apply bottom padding\n  this._cursor.y -= this.paddingBottom\n\n  const height = this._startY - this._cursor.y\n  if (height < this.opts.minHeight) {\n    this._cursor.y -= this.opts.minHeight - height\n  }\n\n  // decrease the counter of active cells\n  row._columns--\n\n  // reset the parent property, to prevent endless recursion when the pageBreak handler of the\n  // cell is called later on\n  this._parent = null\n\n  // keep track of the ended cell\n  row._endedCells.push(this)\n\n  // if, last row has been ended, trigger page break manually to continue with other cells on\n  // the next page\n  if (row._columns > 0 && row._rotated === row._columns) {\n    // TODO: level hardcoded?\n    await row._pageBreak(2, row._insideBreak)\n  }\n\n  // keep track of the ending y which is nearest to the page end\n  if (row._endY === null || this._cursor.y < row._endY) {\n    row._endY = this._cursor.y\n  }\n\n  this._endLayerRef = this._doc._currentContent\n\n  // move to the next cell\n  row._nextColumn()\n}\n"]},"metadata":{},"sourceType":"script"}