{"ast":null,"code":"'use strict';\n\nconst util = require('../util');\n\nclass PDFReference {\n  constructor(obj) {\n    Object.defineProperty(this, 'object', {\n      enumerable: true,\n      get: () => {\n        if (!obj) {\n          return undefined;\n        }\n\n        if (typeof obj === 'function') {\n          obj = obj();\n        }\n\n        return obj;\n      }\n    });\n  }\n\n  toString() {\n    return this.object.id + ' ' + this.object.rev + ' R';\n  }\n\n  static parse(xref, lexer, trial) {\n    const before = lexer.pos;\n    const id = lexer.readNumber(trial);\n\n    if (id === undefined && !trial) {\n      throw new Error('Invalid indirect');\n    }\n\n    lexer.skipWhitespace(1, trial);\n    const generation = lexer.readNumber(trial);\n\n    if (generation === undefined && !trial) {\n      throw new Error('Invalid indirect');\n    }\n\n    lexer.skipWhitespace(1, trial);\n\n    if (lexer.getString(1) !== 'R') {\n      if (trial) {\n        lexer.pos = before;\n        return undefined;\n      }\n\n      throw new Error('Invalid indirect');\n    }\n\n    lexer.shift(1);\n\n    if (!lexer.state.references) {\n      lexer.state.references = new Map();\n    }\n\n    const key = `${id} ${generation}`;\n\n    if (lexer.state.references.has(key)) {\n      return lexer.state.references.get(key);\n    }\n\n    const ref = new PDFReference(parseObject.bind(null, xref, lexer.outer, id));\n    lexer.state.references.set(key, ref);\n    return ref;\n  }\n\n}\n\nmodule.exports = PDFReference;\n\nfunction parseObject(xref, lexer, id) {\n  const PDFObject = require('./object');\n\n  const Lexer = require('../parser/lexer');\n\n  const obj = xref.get(id);\n\n  if (obj) {\n    return obj;\n  }\n\n  const offset = xref.getOffset(id);\n\n  if (offset === null) {\n    const entry = xref.objects[id];\n\n    if (entry.compressed) {\n      if (!entry.obj) {\n        lexer.pos = xref.getOffset(entry.id);\n        const obj = PDFObject.parse(xref, lexer);\n        const type = obj.properties.get('Type');\n\n        if (type && type.name !== 'ObjStm') {\n          throw new Error('Expected compressed object stream');\n        }\n\n        const src = util.inflate(obj); // console.log(\"STRING: \", String.fromCharCode.apply(null, src))\n\n        const innerLexer = new Lexer(src, lexer);\n        obj.lexer = innerLexer;\n        obj.innerObjects = [];\n        const n = obj.properties.get(\"N\");\n\n        for (let i = 0; i < n; ++i) {\n          const id = innerLexer.readNumber(false);\n          innerLexer.skipWhitespace(null, false);\n          const offset = innerLexer.readNumber(false);\n          innerLexer.skipWhitespace(null, true);\n          obj.innerObjects.push({\n            id: id,\n            offset: offset,\n            obj: null\n          });\n        }\n\n        entry.obj = obj;\n      }\n\n      const inner = entry.obj.innerObjects[entry.ix];\n\n      if (!inner.obj) {\n        const innerLexer = entry.obj.lexer;\n        innerLexer.pos = entry.obj.properties.get('First') + inner.offset;\n        inner.obj = PDFObject.parseInner(xref, innerLexer);\n      }\n\n      return inner.obj;\n    } else {\n      throw new Error('Expected compressed object stream');\n    }\n  } else {\n    lexer.pos = offset;\n    return PDFObject.parse(xref, lexer);\n  }\n}","map":{"version":3,"sources":["/mnt/c/Users/Venkatesh/Documents/6th Sem/Web Dev/project/resume-generator/node_modules/pdfjs/lib/object/reference.js"],"names":["util","require","PDFReference","constructor","obj","Object","defineProperty","enumerable","get","undefined","toString","object","id","rev","parse","xref","lexer","trial","before","pos","readNumber","Error","skipWhitespace","generation","getString","shift","state","references","Map","key","has","ref","parseObject","bind","outer","set","module","exports","PDFObject","Lexer","offset","getOffset","entry","objects","compressed","type","properties","name","src","inflate","innerLexer","innerObjects","n","i","push","inner","ix","parseInner"],"mappings":"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","sourcesContent":["'use strict'\n\nconst util = require('../util')\n\nclass PDFReference {\n  constructor(obj) {\n    Object.defineProperty(this, 'object', {\n      enumerable: true,\n      get: () => {\n        if (!obj) {\n          return undefined\n        }\n\n        if (typeof obj === 'function') {\n          obj = obj()\n        }\n\n        return obj\n      }\n    })\n  }\n\n  toString() {\n    return this.object.id + ' ' + this.object.rev + ' R'\n  }\n\n  static parse(xref, lexer, trial) {\n    const before = lexer.pos\n\n    const id = lexer.readNumber(trial)\n    if (id === undefined && !trial) {\n      throw new Error('Invalid indirect')\n    }\n\n    lexer.skipWhitespace(1, trial)\n    const generation = lexer.readNumber(trial)\n    if (generation === undefined && !trial) {\n      throw new Error('Invalid indirect')\n    }\n\n    lexer.skipWhitespace(1, trial)\n    if (lexer.getString(1) !== 'R') {\n      if (trial) {\n        lexer.pos = before\n        return undefined\n      }\n\n      throw new Error('Invalid indirect')\n    }\n\n    lexer.shift(1)\n\n    if (!lexer.state.references) {\n      lexer.state.references = new Map()\n    }\n    const key = `${id} ${generation}`\n    if (lexer.state.references.has(key)) {\n      return lexer.state.references.get(key)\n    }\n\n    const ref = new PDFReference(parseObject.bind(null, xref, lexer.outer, id))\n    lexer.state.references.set(key, ref)\n    return ref\n  }\n}\n\nmodule.exports = PDFReference\n\nfunction parseObject(xref, lexer, id) {\n  const PDFObject = require('./object')\n  const Lexer = require('../parser/lexer')\n\n  const obj = xref.get(id)\n  if (obj) {\n    return obj\n  }\n\n  const offset = xref.getOffset(id)\n  if (offset === null) {\n    const entry = xref.objects[id]\n    if (entry.compressed) {\n      if (!entry.obj) {\n        lexer.pos = xref.getOffset(entry.id)\n        const obj = PDFObject.parse(xref, lexer)\n\n        const type = obj.properties.get('Type')\n        if (type && type.name !== 'ObjStm') {\n          throw new Error('Expected compressed object stream')\n        }\n\n        const src = util.inflate(obj)\n        // console.log(\"STRING: \", String.fromCharCode.apply(null, src))\n        const innerLexer = new Lexer(src, lexer)\n\n        obj.lexer = innerLexer\n        obj.innerObjects = []\n        const n = obj.properties.get(\"N\")\n        for (let i = 0; i < n; ++i) {\n          const id = innerLexer.readNumber(false)\n          innerLexer.skipWhitespace(null, false)\n          const offset = innerLexer.readNumber(false)\n          innerLexer.skipWhitespace(null, true)\n\n          obj.innerObjects.push({\n            id: id,\n            offset: offset,\n            obj: null,\n          })\n        }\n\n        entry.obj = obj\n      }\n\n      const inner = entry.obj.innerObjects[entry.ix]\n      if (!inner.obj) {\n        const innerLexer = entry.obj.lexer\n        innerLexer.pos = entry.obj.properties.get('First') + inner.offset\n\n        inner.obj = PDFObject.parseInner(xref, innerLexer)\n      }\n\n      return inner.obj\n    } else {\n      throw new Error('Expected compressed object stream')\n    }\n  } else {\n    lexer.pos = offset\n    return PDFObject.parse(xref, lexer)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}