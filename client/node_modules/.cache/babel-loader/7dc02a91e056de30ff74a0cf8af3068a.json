{"ast":null,"code":"'use strict';\n\nconst PDF = require('./object');\n\nconst Parser = require('./parser/parser');\n\nconst PROPERTIES_TO_COPY = {\n  colorSpaces: 'ColorSpace',\n  fonts: 'Font',\n  xobjects: 'XObject',\n  extGStates: 'ExtGState',\n  shadings: 'Shading'\n};\nmodule.exports = class ExternalDocument {\n  constructor(src) {\n    const parser = new Parser(src);\n    parser.parse();\n    const catalog = parser.trailer.get('Root').object.properties;\n    const pages = catalog.get('Pages').object.properties;\n    this.pages = pages;\n    this.mediaBox = pages.get('MediaBox');\n    const kids = pages.get('Kids');\n    this.pageCount = this._countPagesRecursively(kids, 0);\n  }\n\n  _countPagesRecursively(kids, i) {\n    for (const kid of kids) {\n      const page = kid.object;\n\n      if (page.properties.get('Type').toString() === '/Pages') {\n        // encountered nested pages\n        i = this._countPagesRecursively(page.properties.get('Kids'), i);\n      } else {\n        i++;\n      }\n    }\n\n    return i;\n  } // TODO: add mutex to not write concurrently (because of document specific _registerObject)\n\n\n  async write(doc, page) {\n    await doc._endPage();\n    const kids = this.pages.get('Kids');\n    const filter = page ? i => i === page - 1 : undefined;\n\n    for (const page of this._iterPagesRecursively(doc, kids, filter)) {\n      // if the page object does not define its MediaBox, explicitly set its MediaBox to the\n      // value defined by its parent Pages object\n      if (!page.properties.has('MediaBox') && this.mediaBox) {\n        page.properties.set('MediaBox', this.mediaBox);\n      } // add single page\n\n\n      doc._registerObject(page, true); // first, register objects to assign IDs (for references)\n\n\n      const objects = [];\n      Parser.addObjectsRecursive(objects, page, 0);\n\n      for (const obj of objects) {\n        doc._registerObject(obj, true);\n      } // write objects\n\n\n      for (const obj of objects) {\n        await doc._writeObject(obj);\n      }\n\n      page.prop('Parent', doc._pagesObj.toReference());\n      await doc._writeObject(page);\n\n      doc._pages.push(page.toReference());\n    }\n  }\n\n  *_iterPagesRecursively(doc, kids, filter, cursor) {\n    if (!cursor) {\n      cursor = {\n        i: 0\n      };\n    }\n\n    for (const kid of kids) {\n      const page = kid.object;\n\n      if (page.properties.get('Type').toString() === '/Pages') {\n        // encountered nested pages\n        yield* this._iterPagesRecursively(doc, page.properties.get('Kids'), filter, cursor);\n        continue;\n      } else if (!filter || filter(cursor.i)) {\n        yield page;\n      }\n\n      cursor.i++;\n    }\n  }\n\n  async setAsTemplate(doc, firstPageOnly) {\n    await doc._endPage(); // take the first page only\n\n    const filter = i => i === 0;\n\n    const kids = this.pages.get('Kids');\n\n    if (!kids[0]) {\n      throw new TypeError('External document is invalid');\n    }\n\n    for (const page of this._iterPagesRecursively(doc, kids, filter)) {\n      // if the page object does not define its MediaBox, explicitly set its MediaBox to the\n      // value defined by its parent Pages object\n      if (!page.properties.has('MediaBox') && this.mediaBox) {\n        page.properties.set('MediaBox', this.mediaBox);\n      }\n\n      const first = page.properties;\n      const objects = [];\n      Parser.addObjectsRecursive(objects, page, 0); // first, register objects to assign IDs (for references)\n\n      for (const obj of objects) {\n        doc._registerObject(obj, true);\n      } // write objects\n\n\n      for (const obj of objects) {\n        await doc._writeObject(obj);\n      }\n\n      let contents = first.get('Contents');\n\n      if (!Array.isArray(contents)) {\n        contents = [contents];\n      }\n\n      let resources = first.get('Resources');\n\n      if (resources instanceof PDF.Reference) {\n        resources = resources.object.properties;\n      }\n\n      doc._template = {\n        contents: contents.map(c => c && c.toString() || ''),\n        colorSpaces: {},\n        fonts: {},\n        xobjects: {},\n        extGStates: {},\n        shadings: {}\n      };\n\n      for (const prop in PROPERTIES_TO_COPY) {\n        const dict = resources && resources.get(PROPERTIES_TO_COPY[prop]);\n\n        if (dict) {\n          for (const alias in dict.dictionary) {\n            doc._template[prop][alias] = dict.dictionary[alias].toString();\n\n            doc._aliases.block(alias);\n          }\n        }\n      }\n\n      doc._template.firstPageOnly = firstPageOnly;\n    }\n  }\n\n  async _getPagesRecursively(doc, kids, i, filter) {\n    for (const kid of kids) {\n      const page = kid.object;\n\n      if (page.properties.get('Type').toString() === '/Pages') {\n        // encountered nested pages\n        i = await this._addPagesRecursively(doc, page.properties.get('Kids'), i, filter);\n        continue;\n      } else if (!filter || filter(i)) {\n        // if the page object does not define its MediaBox, explicitly set its MediaBox to the\n        // value defined by its parent Pages object\n        if (!page.properties.has('MediaBox') && this.mediaBox) {\n          page.properties.set('MediaBox', this.mediaBox);\n        } // add single page\n\n\n        doc._registerObject(page, true); // first, register objects to assign IDs (for references)\n\n\n        const objects = [];\n        Parser.addObjectsRecursive(objects, page, 0);\n\n        for (const obj of objects) {\n          doc._registerObject(obj, true);\n        } // write objects\n\n\n        for (const obj of objects) {\n          await doc._writeObject(obj);\n        }\n\n        page.prop('Parent', doc._pagesObj.toReference());\n        await doc._writeObject(page);\n\n        doc._pages.push(page.toReference());\n      }\n\n      i++;\n    }\n\n    return i;\n  }\n\n};","map":{"version":3,"sources":["/mnt/c/Users/Venkatesh/Documents/6th Sem/Web Dev/project/resume-generator/node_modules/pdfjs/lib/external.js"],"names":["PDF","require","Parser","PROPERTIES_TO_COPY","colorSpaces","fonts","xobjects","extGStates","shadings","module","exports","ExternalDocument","constructor","src","parser","parse","catalog","trailer","get","object","properties","pages","mediaBox","kids","pageCount","_countPagesRecursively","i","kid","page","toString","write","doc","_endPage","filter","undefined","_iterPagesRecursively","has","set","_registerObject","objects","addObjectsRecursive","obj","_writeObject","prop","_pagesObj","toReference","_pages","push","cursor","setAsTemplate","firstPageOnly","TypeError","first","contents","Array","isArray","resources","Reference","_template","map","c","dict","alias","dictionary","_aliases","block","_getPagesRecursively","_addPagesRecursively"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PDF = require('./object')\nconst Parser = require('./parser/parser')\n\nconst PROPERTIES_TO_COPY = {\n  colorSpaces: 'ColorSpace',\n  fonts: 'Font',\n  xobjects: 'XObject',\n  extGStates: 'ExtGState',\n  shadings: 'Shading',\n}\n\nmodule.exports = class ExternalDocument {\n  constructor(src) {\n    const parser = new Parser(src)\n    parser.parse()\n\n    const catalog  = parser.trailer.get('Root').object.properties\n    const pages    = catalog.get('Pages').object.properties\n\n    this.pages = pages\n    this.mediaBox = pages.get('MediaBox')\n\n    const kids = pages.get('Kids')\n    this.pageCount = this._countPagesRecursively(kids, 0)\n  }\n\n  _countPagesRecursively(kids, i) {\n    for (const kid of kids) {\n      const page = kid.object\n      if (page.properties.get('Type').toString() === '/Pages') {\n        // encountered nested pages\n        i = this._countPagesRecursively(page.properties.get('Kids'), i)\n      } else {\n        i++\n      }\n    }\n\n    return i\n  }\n\n  // TODO: add mutex to not write concurrently (because of document specific _registerObject)\n  async write(doc, page) {\n    await doc._endPage()\n\n    const kids = this.pages.get('Kids')\n    const filter = page ? ((i) => i === (page - 1)) : undefined\n\n    for (const page of this._iterPagesRecursively(doc, kids, filter)) {\n      // if the page object does not define its MediaBox, explicitly set its MediaBox to the\n      // value defined by its parent Pages object\n      if (!page.properties.has('MediaBox') && this.mediaBox) {\n        page.properties.set('MediaBox', this.mediaBox)\n      }\n\n      // add single page\n      doc._registerObject(page, true)\n\n      // first, register objects to assign IDs (for references)\n      const objects = []\n      Parser.addObjectsRecursive(objects, page, 0)\n      for (const obj of objects) {\n        doc._registerObject(obj, true)\n      }\n\n      // write objects\n      for (const obj of objects) {\n        await doc._writeObject(obj)\n      }\n\n      page.prop('Parent', doc._pagesObj.toReference())\n      await doc._writeObject(page)\n\n      doc._pages.push(page.toReference())\n    }\n  }\n\n  * _iterPagesRecursively(doc, kids, filter, cursor) {\n    if (!cursor) {\n      cursor = { i: 0 }\n    }\n\n    for (const kid of kids) {\n      const page = kid.object\n\n      if (page.properties.get('Type').toString() === '/Pages') {\n        // encountered nested pages\n        yield* this._iterPagesRecursively(doc, page.properties.get('Kids'), filter, cursor)\n        continue\n      } else if (!filter || filter(cursor.i)) {\n        yield page\n      }\n\n      cursor.i++\n    }\n  }\n\n  async setAsTemplate(doc, firstPageOnly) {\n    await doc._endPage()\n\n    // take the first page only\n    const filter = i => i === 0\n    const kids = this.pages.get('Kids')\n    if (!kids[0]) {\n      throw new TypeError('External document is invalid')\n    }\n\n    for (const page of this._iterPagesRecursively(doc, kids, filter)) {\n      // if the page object does not define its MediaBox, explicitly set its MediaBox to the\n      // value defined by its parent Pages object\n      if (!page.properties.has('MediaBox') && this.mediaBox) {\n        page.properties.set('MediaBox', this.mediaBox)\n      }\n      const first = page.properties\n      const objects = []\n      Parser.addObjectsRecursive(objects, page, 0)\n\n      // first, register objects to assign IDs (for references)\n      for (const obj of objects) {\n        doc._registerObject(obj, true)\n      }\n\n      // write objects\n      for (const obj of objects) {\n        await doc._writeObject(obj)\n      }\n\n      let contents = first.get('Contents')\n      if (!Array.isArray(contents)) {\n        contents = [contents]\n      }\n\n      let resources = first.get('Resources')\n      if (resources instanceof PDF.Reference) {\n      resources = resources.object.properties\n      }\n\n      doc._template = {\n        contents: contents.map(c => ((c && c.toString()) || '')),\n        colorSpaces: {},\n        fonts: {},\n        xobjects: {},\n        extGStates: {},\n        shadings: {},\n      }\n\n      for (const prop in PROPERTIES_TO_COPY) {\n        const dict = resources && resources.get(PROPERTIES_TO_COPY[prop])\n        if (dict) {\n          for (const alias in dict.dictionary) {\n            doc._template[prop][alias] = dict.dictionary[alias].toString()\n            doc._aliases.block(alias)\n          }\n        }\n      }\n\n      doc._template.firstPageOnly = firstPageOnly\n    }\n  }\n\n  async _getPagesRecursively(doc, kids, i, filter) {\n    for (const kid of kids) {\n      const page = kid.object\n\n      if (page.properties.get('Type').toString() === '/Pages') {\n        // encountered nested pages\n        i = await this._addPagesRecursively(doc, page.properties.get('Kids'), i, filter)\n        continue\n      } else if (!filter || filter(i)) {\n        // if the page object does not define its MediaBox, explicitly set its MediaBox to the\n        // value defined by its parent Pages object\n        if (!page.properties.has('MediaBox') && this.mediaBox) {\n          page.properties.set('MediaBox', this.mediaBox)\n        }\n\n        // add single page\n        doc._registerObject(page, true)\n\n        // first, register objects to assign IDs (for references)\n        const objects = []\n        Parser.addObjectsRecursive(objects, page, 0)\n        for (const obj of objects) {\n          doc._registerObject(obj, true)\n        }\n\n        // write objects\n        for (const obj of objects) {\n          await doc._writeObject(obj)\n        }\n\n        page.prop('Parent', doc._pagesObj.toReference())\n        await doc._writeObject(page)\n\n        doc._pages.push(page.toReference())\n      }\n\n      i++\n    }\n\n    return i\n  }\n}\n\n\n"]},"metadata":{},"sourceType":"script"}