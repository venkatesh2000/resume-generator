{"ast":null,"code":"'use strict';\n\nconst Fragment = require('./fragment');\n\nconst LineBreaker = require('@rkusa/linebreak');\n\nconst unorm = require('unorm');\n\nconst ops = require('./ops');\n\nconst util = require('./util');\n\nconst Font = require('./font/base');\n\nconst PDF = require('./object');\n\nconst UNDERLINE_FLAG = 1;\nconst STRIKETHROUGH_FLAG = 2;\nconst Text = module.exports = class Text extends Fragment {\n  constructor(doc, parent, opts) {\n    super(doc, parent);\n    this._line = [];\n    this._spaceLeft = 0;\n    this._parts = 0;\n    this._isFirstLine = true;\n    this._isNewLine = true;\n    this._previousFont = null;\n    this._previousFontSize = null;\n    this._previousColor = null;\n    this._previousHeight = 0;\n    this._previousDescent = 0;\n    this.opts = opts;\n    this.defaultFont = opts.font || this._doc.defaultFont;\n    this.defaultFontSize = opts.fontSize || this._doc.defaultFontSize;\n    this.defaultColor = opts.color && util.colorToRgb(opts.color) || this._doc.defaultColor;\n    this.defaultLineHeight = opts.lineHeight || this._doc.defaultLineHeight;\n    this.defaultDecoration = (opts.underline ? UNDERLINE_FLAG : 0) | (opts.strikethrough ? STRIKETHROUGH_FLAG : 0);\n    this.alignment = opts.alignment || opts.textAlign || 'left';\n    this.link = opts.link;\n    this.destination = opts.destination;\n    this.goTo = opts.goTo;\n  } /// private API\n\n\n  async _start() {\n    if (!this._doc._currentContent) {\n      await this._doc._startPage();\n    }\n\n    this._spaceLeft = this._cursor.width;\n  }\n\n  async _end() {\n    // write end text\n    await this._doc._write(ops.ET());\n  }\n\n  async _render(text, opts) {\n    this._parts--;\n\n    if (!Font.isFont(opts.font || this.defaultFont)) {\n      throw new TypeError('invalid font: ' + font);\n    }\n\n    const font = this._doc._fontInstance(opts.font || this.defaultFont);\n\n    const fontSize = opts.fontSize || this.defaultFontSize;\n    const color = opts.color && util.colorToRgb(opts.color) || this.defaultColor;\n    const lineHeight = opts.lineHeight || this.defaultLineHeight;\n    const link = opts.link || this.link;\n    const destination = opts.destination || this.destination;\n    const goTo = opts.goTo || this.goTo;\n    const decoration = this.defaultDecoration | (opts.underline ? UNDERLINE_FLAG : 0) | (opts.strikethrough ? STRIKETHROUGH_FLAG : 0); // enforce string\n\n    text = String(text);\n    text = text.replace(/\\r\\n/g, '\\n').replace(/\\u2028|\\u2029/g, ''); // <- TODO: does this break things?\n\n    const breaker = new LineBreaker(text);\n    let last = 0,\n        bk;\n    const isLastTextChunk = this._parts === 0 && this._ended;\n    let postponeLinebreak = false;\n    let nextWord = null;\n\n    while (nextWord !== null || postponeLinebreak || (bk = breaker.nextBreak()) || isLastTextChunk && this._line.length > 0) {\n      let word = null;\n\n      if (nextWord) {\n        word = nextWord;\n        nextWord = null;\n      } // when there is no break, there is an orphan word that just has to be rendered,\n      // i.e., skip to the line rendering\n      else if (bk) {\n          let until = bk.position;\n          const lastIsSpace = text[bk.position - 1].match(/\\s/);\n\n          if (lastIsSpace) {\n            until--;\n          } // get the string between the last break and this one\n\n\n          word = text.slice(last, until); // separate words, if has whitespace, is at the end of the text or\n          // ends with a whitespace\n\n          if (bk.position === text.length || lastIsSpace) {\n            last = bk.position;\n          } else {\n            continue;\n          }\n\n          word = unorm.nfc(word);\n        }\n\n      let wordWidth = 0;\n      let offsetWidth = 0;\n      let spaceWidth = 0;\n\n      if (word) {\n        wordWidth = font.stringWidth(word, fontSize);\n        offsetWidth = wordWidth.width;\n        spaceWidth = font.stringWidth(' ', fontSize).width; // add whitespace length for every word, except the first on in the line\n        // on the first line, during the first word the line array is empty, however, for succeeding\n        // lines the line array already contains the word that did not fit into the previous line\n\n        if (this._line.length > (this._isNewLine ? 0 : 1)) {\n          offsetWidth += spaceWidth;\n        }\n      } // render line if there is a line break, if we hit the last word of the text, if we\n      // have manual page breaks, or if there is not enough space on the line left\n\n\n      const isLastWord = (!bk || bk.position === text.length) && isLastTextChunk;\n      const notEnoughSpace = this._spaceLeft < offsetWidth;\n\n      if (postponeLinebreak || bk && bk.required || isLastWord || notEnoughSpace) {\n        // if word is longer than one line\n        if (this._line.length === 0 && notEnoughSpace) {\n          // split word\n          for (let i = word.length - 1; i >= 0; --i) {\n            const w = font.stringWidth(word.slice(i), fontSize);\n\n            if (this._spaceLeft >= offsetWidth - w.width) {\n              const subword = word.slice(0, i);\n\n              this._line.push(new TextChunk({\n                wordWidth: font.stringWidth(subword, fontSize),\n                spaceWidth,\n                word: subword,\n                font,\n                fontSize,\n                color,\n                decoration,\n                link,\n                destination,\n                goTo\n              }));\n\n              offsetWidth -= w.width;\n              this._spaceLeft -= offsetWidth;\n              nextWord = word.slice(i);\n              word = null;\n              break;\n            }\n          }\n        } // if there is enough space, add word to the current line\n\n\n        if (!postponeLinebreak && word && this._spaceLeft - offsetWidth >= 0) {\n          this._line.push(new TextChunk({\n            wordWidth,\n            spaceWidth,\n            word,\n            font,\n            fontSize,\n            color,\n            decoration,\n            link,\n            destination,\n            goTo\n          }));\n\n          this._spaceLeft -= offsetWidth;\n          word = null;\n        } // render line\n\n\n        let left = this._cursor.x; // calc max line height\n\n        let height = 0;\n        let descent = 0;\n\n        for (const w of this._line) {\n          const h = w.font.lineHeight(w.fontSize, true);\n\n          if (h > height) {\n            height = h;\n          }\n\n          const d = -w.font.descent(w.fontSize);\n\n          if (d > descent) {\n            descent = d;\n          }\n        }\n\n        height *= lineHeight;\n        descent *= lineHeight;\n\n        if (height === 0) {\n          height = this._previousHeight;\n          descent = this._previousDescent;\n        } // break page if necessary\n\n\n        if (!this._cursor.doesFit(height)) {\n          if (!this._isFirstLine) {\n            await this._doc._write(ops.ET());\n          } // execute page break\n          // add remaining text as new text to the queue of pending operations\n\n\n          let remainingText = bk ? (word ? word + ' ' : '') + text.substring(bk.position) : '';\n\n          if (bk && bk.required) {\n            // if the page break happened due to a line break, we have to make sure to add it back\n            // to the queue as well\n            remainingText += '\\n';\n          }\n\n          this._pending.unshift(() => {\n            this._parts++;\n            return this._render(remainingText, opts);\n          });\n\n          await this._parent._pageBreak(1);\n          this._isFirstLine = true;\n          this._isNewLine = true;\n          this._previousFont = null;\n          this._previousFontSize = null;\n          this._previousColor = null;\n          break;\n        } // shift cursor; since rendering is done above the y coordinate,\n        // we have to update the cursor before rendering the line\n\n\n        this._cursor.y -= height; // shift y cursor\n        // calculate remaining space\n\n        const freeSpace = this._spaceLeft; // alignment\n\n        let spacing = 0;\n\n        switch (this.alignment) {\n          case 'right':\n            left += freeSpace;\n            break;\n\n          case 'center':\n            left += this._cursor.width / 2 - (this._cursor.width - freeSpace) / 2;\n            break;\n\n          case 'justify':\n            const isLastLine = isLastWord || bk && bk.required;\n\n            if (isLastLine && freeSpace / this._cursor.width > .2) {\n              break;\n            }\n\n            if (this._line.length > 1) {\n              spacing = freeSpace / (this._line.length - 1);\n            }\n\n            break;\n        } // render words\n\n\n        let chunk = '';\n\n        if (this._isFirstLine) {\n          this._previousHeight = height;\n          chunk += ops.BT() // set initial pos\n          + ops.Tm(1, 0, 0, 1, left, this._cursor.y) // set leading\n          + ops.TL(this._previousHeight);\n        } else {\n          const lh = height + this._previousDescent;\n\n          if (height > 0 && lh !== this._previousHeight) {\n            this._previousHeight = lh;\n            chunk += ops.TL(lh);\n          }\n\n          if (left > this._cursor.x) {\n            // set new x and y position\n            chunk += ops.Tm(1, 0, 0, 1, left, this._cursor.y);\n          } else {\n            // move to next line\n            chunk += ops.Tstar();\n          }\n        }\n\n        if (height > 0) {\n          this._previousDescent = descent;\n        }\n\n        const out = [];\n        const rangeStyleArgs = [this._doc, left, this._cursor.y, height, spacing];\n        const underlineStyle = new UnderlineRangeStyle(...rangeStyleArgs);\n        const strikethroughStyle = new StrikethroughRangeStyle(...rangeStyleArgs);\n        const linkStyle = new LinkRangeStyle(...rangeStyleArgs);\n        const destinationStyle = new DestinationRangeStyle(...rangeStyleArgs);\n        const goToStyle = new GoToRangeStyle(...rangeStyleArgs);\n        const lastIx = this._line.length - 1;\n\n        for (let i = 0; i < this._line.length; ++i) {\n          const w = this._line[i];\n          const fontStyleChanged = w.font !== this._previousFont || w.fontSize !== this._previousFontSize;\n          const colorChanged = !util.rgbEqual(w.color, this._previousColor);\n          chunk += underlineStyle.applyStyle(w, i === lastIx, fontStyleChanged || colorChanged);\n          chunk += strikethroughStyle.applyStyle(w, i === lastIx, fontStyleChanged || colorChanged);\n          chunk += linkStyle.applyStyle(w, i === lastIx, fontStyleChanged || colorChanged);\n          chunk += destinationStyle.applyStyle(w, i === lastIx, fontStyleChanged || colorChanged);\n          chunk += goToStyle.applyStyle(w, i === lastIx, fontStyleChanged || colorChanged);\n\n          if (fontStyleChanged || colorChanged) {\n            if (out.length > 0) {\n              chunk += ops.TJ(out);\n            }\n\n            if (fontStyleChanged) {\n              this._previousFont = w.font;\n              this._previousFontSize = w.fontSize;\n\n              const alias = this._doc._fontAlias(w.font); // set font and font size\n\n\n              chunk += ops.Tf(alias, w.fontSize);\n            } // set color if it has changed\n\n\n            if (colorChanged) {\n              this._previousColor = w.color;\n              chunk += ops.sc(...w.color);\n            }\n\n            out.length = 0;\n          }\n\n          const kerning = w.wordWidth.kerning;\n\n          if (kerning.length > 0) {\n            let pos = 0;\n\n            for (let i = 0; i < kerning.length; ++i) {\n              let subword = w.word.substring(pos, kerning[i].pos);\n              out.push(w.font.encode(subword), kerning[i].offset);\n              pos = kerning[i].pos;\n            }\n\n            out.push(w.font.encode(w.word.substring(pos)));\n          } else {\n            out.push(w.font.encode(w.word));\n          }\n\n          if (i < this._line.length - 1 && w.spaceWidth > 0) {\n            // if is not last and has spaceWidth set\n            out.push(calcSpaceWidth(spacing, w.font, w.fontSize));\n          }\n        }\n\n        if (out.length > 0) {\n          chunk += ops.TJ(out);\n        }\n\n        await this._doc._write(chunk);\n        this._cursor.y -= descent; // reset / update variables\n\n        this._spaceLeft = this._cursor.width;\n        this._line.length = 0; // empty line array\n\n        this._isFirstLine = false;\n        this._isNewLine = bk && bk.required;\n        postponeLinebreak = bk && bk.required && word !== null && word.length > 0;\n      } // consider word for next line\n\n\n      if (word) {\n        this._line.push(new TextChunk({\n          wordWidth,\n          spaceWidth,\n          word,\n          font,\n          fontSize,\n          color,\n          decoration,\n          link,\n          destination,\n          goTo\n        }));\n\n        this._spaceLeft -= offsetWidth;\n      }\n\n      bk = null;\n    }\n  } /// public API\n\n\n  add(text, opts) {\n    this._begin(null); // trigger error, if text is already ended\n\n\n    this._parts++;\n\n    this._pending.push(() => this._render(text, opts || {}));\n\n    return this;\n  }\n\n  append(text, opts) {\n    this._begin(null); // trigger error, if text is already ended\n\n\n    this._parts++;\n\n    this._pending.push(() => {\n      if (this._line.length > 0) {\n        const w = this._line[this._line.length - 1];\n        this._spaceLeft += w.spaceWidth;\n        w.spaceWidth = 0; // set space width to zero\n      }\n\n      return this._render(text, opts || {});\n    });\n\n    return this;\n  }\n\n  br() {\n    this._begin(null); // trigger error, if text is already ended\n\n\n    this._parts++;\n\n    this._pending.push(() => this._render('\\n\\n', {}));\n\n    return this;\n  }\n\n};\n\nfunction calcSpaceWidth(spacing, font, fontSize) {\n  const scaleFactor = 1000 / fontSize;\n  return -(spacing + font.stringWidth(' ', fontSize)) * scaleFactor;\n}\n\nclass TextChunk {\n  constructor(values) {\n    this.wordWidth = values.wordWidth;\n    this.spaceWidth = values.spaceWidth;\n    this.word = values.word;\n    this.font = values.font;\n    this.fontSize = values.fontSize;\n    this.color = values.color;\n    this.decoration = values.decoration;\n    this.link = values.link;\n    this.destination = values.destination;\n    this.goTo = values.goTo;\n  }\n\n}\n\nclass RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    this.doc = doc;\n    this.from = x;\n    this.width = 0;\n    this.y = y;\n    this.height = height;\n    this.spacing = spacing;\n    this.isActive = false;\n    this.lastSpaceWidth = 0;\n  }\n\n  applyStyle(textChunk, isLast, fontStyleChanged) {\n    const shouldApply = this._active(textChunk);\n\n    let chunk = '';\n\n    if (shouldApply && !fontStyleChanged && this.isActive) {\n      this.width += this.lastSpaceWidth;\n    }\n\n    if (this.isActive && (!shouldApply || fontStyleChanged)) {\n      chunk += this._applyStyle(textChunk);\n      this.from += this.width + this.lastSpaceWidth;\n      this.width = 0;\n    }\n\n    if (!this.isActive || shouldApply || this.isActive && fontStyleChanged) {\n      this._start(textChunk);\n    }\n\n    this.isActive = shouldApply;\n    this.lastSpaceWidth = this.spacing || textChunk.spaceWidth;\n\n    if (this.isActive) {\n      this.width += textChunk.wordWidth;\n    } else {\n      this.from += textChunk.wordWidth + this.lastSpaceWidth;\n    }\n\n    if (this.isActive && isLast) {\n      chunk += this._applyStyle(textChunk);\n    }\n\n    return chunk;\n  }\n\n  _active(textChunk) {// abstract\n  }\n\n  _start(textChunk) {// abstract\n  }\n\n  _applyStyle(textChunk) {// abstract\n  }\n\n}\n\nclass UnderlineRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing);\n    this.underlinePosition = 0;\n    this.underlineThickness = 0;\n    this.color = null;\n  }\n\n  _active(textChunk) {\n    return textChunk.decoration & UNDERLINE_FLAG;\n  }\n\n  _start(textChunk) {\n    this.underlinePosition = textChunk.font.underlinePosition(textChunk.fontSize);\n    this.underlineThickness = textChunk.font.underlineThickness(textChunk.fontSize);\n    this.color = textChunk.color;\n  }\n\n  _applyStyle(textChunk) {\n    const y = this.y + this.underlinePosition;\n    return ops.w(this.underlineThickness) // line width\n    + ops.SC(...this.color) // stroking color\n    + ops.S(this.from, y, 'm', this.from + this.width, y, 'l'); // line\n  }\n\n}\n\nclass StrikethroughRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing);\n    this.ascent = 0;\n    this.lineThickness = 0;\n    this.color = null;\n  }\n\n  _active(textChunk) {\n    return textChunk.decoration & STRIKETHROUGH_FLAG;\n  }\n\n  _start(textChunk) {\n    this.ascent = textChunk.font.ascent(textChunk.fontSize);\n    this.lineThickness = textChunk.font.underlineThickness(textChunk.fontSize);\n    this.color = textChunk.color;\n  }\n\n  _applyStyle(textChunk) {\n    const y = this.y + this.ascent * .35;\n    return ops.w(this.lineThickness) // line width\n    + ops.SC(...this.color) // stroking color\n    + ops.S(this.from, y, 'm', this.from + this.width, y, 'l'); // line\n  }\n\n}\n\nclass LinkRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing);\n    this.link = null;\n  }\n\n  applyStyle(textChunk, isLast, fontStyleChanged) {\n    if (this.link && textChunk.link !== this.link) {\n      fontStyleChanged = true;\n    }\n\n    return RangeStyle.prototype.applyStyle.call(this, textChunk, isLast, fontStyleChanged);\n  }\n\n  _active(textChunk) {\n    return textChunk.link !== undefined;\n  }\n\n  _start(textChunk) {\n    this.link = textChunk.link;\n  }\n\n  _applyStyle(textChunk) {\n    this.doc._annotations.push(new PDF.Dictionary({\n      Type: 'Annot',\n      Subtype: 'Link',\n      Rect: new PDF.Array([this.from, this.y, this.from + this.width, this.y + this.height]),\n      Border: new PDF.Array([0, 0, 0]),\n      A: new PDF.Dictionary({\n        Type: 'Action',\n        S: 'URI',\n        URI: new PDF.String(this.link)\n      })\n    }));\n\n    return '';\n  }\n\n}\n\nclass DestinationRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing);\n    this.destination = null;\n  }\n\n  applyStyle(textChunk, isLast, fontStyleChanged) {\n    if (this.destination && textChunk.destination !== this.destination) {\n      fontStyleChanged = true;\n    }\n\n    return RangeStyle.prototype.applyStyle.call(this, textChunk, isLast, fontStyleChanged);\n  }\n\n  _active(textChunk) {\n    return textChunk.destination !== undefined;\n  }\n\n  _start(textChunk) {\n    this.destination = textChunk.destination;\n  }\n\n  _applyStyle(textChunk) {\n    this.doc._destinations.set(this.destination, new PDF.Array([this.doc._currentPage.toReference(), new PDF.Name('XYZ'), this.from, this.y, null]));\n\n    return '';\n  }\n\n}\n\nclass GoToRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing);\n    this.goTo = null;\n  }\n\n  applyStyle(textChunk, isLast, fontStyleChanged) {\n    if (this.goTo && textChunk.goTo !== this.goTo) {\n      fontStyleChanged = true;\n    }\n\n    return RangeStyle.prototype.applyStyle.call(this, textChunk, isLast, fontStyleChanged);\n  }\n\n  _active(textChunk) {\n    return textChunk.goTo !== undefined;\n  }\n\n  _start(textChunk) {\n    this.goTo = textChunk.goTo;\n  }\n\n  _applyStyle(textChunk) {\n    this.doc._annotations.push(new PDF.Dictionary({\n      Type: 'Annot',\n      Subtype: 'Link',\n      Rect: new PDF.Array([this.from, this.y, this.from + this.width, this.y + this.height]),\n      Border: new PDF.Array([0, 0, 0]),\n      A: new PDF.Dictionary({\n        S: 'GoTo',\n        D: new PDF.String(this.goTo)\n      })\n    }));\n\n    return '';\n  }\n\n}\n\nText.DestinationRangeStyle = DestinationRangeStyle;","map":{"version":3,"sources":["/mnt/c/Users/Venkatesh/Documents/6th Sem/Web Dev/project/resume-generator/node_modules/pdfjs/lib/text.js"],"names":["Fragment","require","LineBreaker","unorm","ops","util","Font","PDF","UNDERLINE_FLAG","STRIKETHROUGH_FLAG","Text","module","exports","constructor","doc","parent","opts","_line","_spaceLeft","_parts","_isFirstLine","_isNewLine","_previousFont","_previousFontSize","_previousColor","_previousHeight","_previousDescent","defaultFont","font","_doc","defaultFontSize","fontSize","defaultColor","color","colorToRgb","defaultLineHeight","lineHeight","defaultDecoration","underline","strikethrough","alignment","textAlign","link","destination","goTo","_start","_currentContent","_startPage","_cursor","width","_end","_write","ET","_render","text","isFont","TypeError","_fontInstance","decoration","String","replace","breaker","last","bk","isLastTextChunk","_ended","postponeLinebreak","nextWord","nextBreak","length","word","until","position","lastIsSpace","match","slice","nfc","wordWidth","offsetWidth","spaceWidth","stringWidth","isLastWord","notEnoughSpace","required","i","w","subword","push","TextChunk","left","x","height","descent","h","d","doesFit","remainingText","substring","_pending","unshift","_parent","_pageBreak","y","freeSpace","spacing","isLastLine","chunk","BT","Tm","TL","lh","Tstar","out","rangeStyleArgs","underlineStyle","UnderlineRangeStyle","strikethroughStyle","StrikethroughRangeStyle","linkStyle","LinkRangeStyle","destinationStyle","DestinationRangeStyle","goToStyle","GoToRangeStyle","lastIx","fontStyleChanged","colorChanged","rgbEqual","applyStyle","TJ","alias","_fontAlias","Tf","sc","kerning","pos","encode","offset","calcSpaceWidth","add","_begin","append","br","scaleFactor","values","RangeStyle","from","isActive","lastSpaceWidth","textChunk","isLast","shouldApply","_active","_applyStyle","underlinePosition","underlineThickness","SC","S","ascent","lineThickness","prototype","call","undefined","_annotations","Dictionary","Type","Subtype","Rect","Array","Border","A","URI","_destinations","set","_currentPage","toReference","Name","D"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Fragment = require('./fragment')\nconst LineBreaker = require('@rkusa/linebreak')\nconst unorm = require('unorm')\nconst ops = require('./ops')\nconst util = require('./util')\nconst Font = require('./font/base')\nconst PDF = require('./object')\n\nconst UNDERLINE_FLAG = 1\nconst STRIKETHROUGH_FLAG = 2\n\nconst Text = module.exports = class Text extends Fragment {\n  constructor(doc, parent, opts) {\n    super(doc, parent)\n\n    this._line = []\n    this._spaceLeft = 0\n    this._parts = 0\n    this._isFirstLine = true\n    this._isNewLine = true\n\n    this._previousFont = null\n    this._previousFontSize = null\n    this._previousColor = null\n\n    this._previousHeight = 0\n    this._previousDescent = 0\n\n    this.opts = opts\n    this.defaultFont = opts.font || this._doc.defaultFont\n    this.defaultFontSize = opts.fontSize || this._doc.defaultFontSize\n    this.defaultColor = opts.color && util.colorToRgb(opts.color) || this._doc.defaultColor\n    this.defaultLineHeight = opts.lineHeight || this._doc.defaultLineHeight\n    this.defaultDecoration = (opts.underline ? UNDERLINE_FLAG : 0) | (opts.strikethrough ? STRIKETHROUGH_FLAG : 0)\n\n    this.alignment = opts.alignment || opts.textAlign || 'left'\n\n    this.link = opts.link\n    this.destination = opts.destination\n    this.goTo = opts.goTo\n  }\n\n  /// private API\n\n  async _start() {\n    if (!this._doc._currentContent) {\n      await this._doc._startPage()\n    }\n\n    this._spaceLeft = this._cursor.width\n  }\n\n  async _end() {\n    // write end text\n    await this._doc._write(ops.ET())\n  }\n\n  async _render(text, opts) {\n    this._parts--\n\n    if (!Font.isFont(opts.font || this.defaultFont)) {\n      throw new TypeError('invalid font: ' + font)\n    }\n\n    const font = this._doc._fontInstance(opts.font || this.defaultFont)\n    const fontSize = opts.fontSize || this.defaultFontSize\n    const color = opts.color && util.colorToRgb(opts.color) || this.defaultColor\n    const lineHeight = opts.lineHeight || this.defaultLineHeight\n    const link = opts.link || this.link\n    const destination = opts.destination || this.destination\n    const goTo = opts.goTo || this.goTo\n    const decoration = this.defaultDecoration | (opts.underline ? UNDERLINE_FLAG : 0) | (opts.strikethrough ? STRIKETHROUGH_FLAG : 0)\n\n    // enforce string\n    text = String(text)\n    text = text.replace(/\\r\\n/g, '\\n')\n               .replace(/\\u2028|\\u2029/g, '') // <- TODO: does this break things?\n\n    const breaker = new LineBreaker(text)\n    let last = 0, bk\n\n    const isLastTextChunk = this._parts === 0 && this._ended\n    let postponeLinebreak = false\n    let nextWord = null\n\n    while (nextWord !== null || postponeLinebreak || (bk = breaker.nextBreak()) || (isLastTextChunk && this._line.length > 0)) {\n      let word = null\n\n      if (nextWord) {\n        word = nextWord\n        nextWord = null\n      }\n      // when there is no break, there is an orphan word that just has to be rendered,\n      // i.e., skip to the line rendering\n      else if (bk) {\n        let until = bk.position\n\n        const lastIsSpace = text[bk.position - 1].match(/\\s/)\n        if (lastIsSpace) {\n          until--\n        }\n\n        // get the string between the last break and this one\n        word = text.slice(last, until)\n\n        // separate words, if has whitespace, is at the end of the text or\n        // ends with a whitespace\n        if (bk.position === text.length || lastIsSpace) {\n          last = bk.position\n        } else {\n          continue\n        }\n\n        word = unorm.nfc(word)\n      }\n\n      let wordWidth = 0\n      let offsetWidth = 0\n      let spaceWidth = 0\n\n      if (word) {\n        wordWidth = font.stringWidth(word, fontSize)\n        offsetWidth = wordWidth.width\n        spaceWidth = font.stringWidth(' ', fontSize).width\n\n        // add whitespace length for every word, except the first on in the line\n        // on the first line, during the first word the line array is empty, however, for succeeding\n        // lines the line array already contains the word that did not fit into the previous line\n        if (this._line.length > (this._isNewLine ? 0 : 1)) {\n          offsetWidth += spaceWidth\n        }\n      }\n\n      // render line if there is a line break, if we hit the last word of the text, if we\n      // have manual page breaks, or if there is not enough space on the line left\n      const isLastWord = (!bk || bk.position === text.length) && isLastTextChunk\n      const notEnoughSpace = this._spaceLeft < offsetWidth\n      if (postponeLinebreak || (bk && bk.required) || isLastWord || notEnoughSpace) {\n        // if word is longer than one line\n        if (this._line.length === 0 && notEnoughSpace) {\n          // split word\n          for (let i = word.length - 1; i >= 0; --i) {\n            const w = font.stringWidth(word.slice(i), fontSize)\n\n            if (this._spaceLeft >= offsetWidth - w.width) {\n              const subword = word.slice(0, i)\n              this._line.push(\n                new TextChunk({\n                  wordWidth: font.stringWidth(subword, fontSize),\n                  spaceWidth, word: subword,\n                  font, fontSize, color, decoration,\n                  link, destination, goTo\n                })\n              )\n              offsetWidth -= w.width\n              this._spaceLeft -= offsetWidth\n\n              nextWord = word.slice(i)\n              word = null\n\n              break\n            }\n          }\n        }\n\n        // if there is enough space, add word to the current line\n        if (!postponeLinebreak && word && (this._spaceLeft - offsetWidth) >= 0) {\n          this._line.push(\n            new TextChunk({\n              wordWidth, spaceWidth, word, font, fontSize,\n              color, decoration,\n              link, destination, goTo\n            })\n          )\n          this._spaceLeft -= offsetWidth\n          word = null\n        }\n\n        // render line\n        let left = this._cursor.x\n\n        // calc max line height\n        let height = 0\n        let descent = 0\n\n        for (const w of this._line) {\n          const h = w.font.lineHeight(w.fontSize, true)\n          if (h > height) {\n            height = h\n          }\n\n          const d = -w.font.descent(w.fontSize)\n          if (d > descent) {\n            descent = d\n          }\n        }\n\n        height *= lineHeight\n        descent *= lineHeight\n\n        if (height === 0) {\n          height = this._previousHeight\n          descent = this._previousDescent\n        }\n\n        // break page if necessary\n        if (!this._cursor.doesFit(height)) {\n          if (!this._isFirstLine) {\n            await this._doc._write(ops.ET())\n          }\n\n          // execute page break\n          // add remaining text as new text to the queue of pending operations\n          let remainingText = bk ? ((word ? (word + ' ') : '') + text.substring(bk.position)) : ''\n          if (bk && bk.required) {\n            // if the page break happened due to a line break, we have to make sure to add it back\n            // to the queue as well\n            remainingText += '\\n';\n          }\n\n          this._pending.unshift(() => {\n            this._parts++\n            return this._render(remainingText, opts)\n          })\n\n          await this._parent._pageBreak(1)\n\n          this._isFirstLine = true\n          this._isNewLine = true\n          this._previousFont = null\n          this._previousFontSize = null\n          this._previousColor = null\n\n          break\n        }\n\n        // shift cursor; since rendering is done above the y coordinate,\n        // we have to update the cursor before rendering the line\n        this._cursor.y -= height // shift y cursor\n\n        // calculate remaining space\n        const freeSpace = this._spaceLeft\n\n        // alignment\n        let spacing = 0\n        switch (this.alignment) {\n        case 'right':\n          left += freeSpace\n          break\n        case 'center':\n          left += this._cursor.width / 2 - (this._cursor.width - freeSpace) / 2\n          break\n        case 'justify':\n          const isLastLine = isLastWord || (bk && bk.required)\n          if (isLastLine && freeSpace / this._cursor.width > .2) {\n            break\n          }\n          if (this._line.length > 1) {\n            spacing = freeSpace / (this._line.length - 1)\n          }\n          break\n        }\n\n        // render words\n        let chunk = ''\n\n        if (this._isFirstLine) {\n          this._previousHeight = height\n          chunk += ops.BT()\n                // set initial pos\n                + ops.Tm(1, 0, 0, 1, left, this._cursor.y)\n                // set leading\n                + ops.TL(this._previousHeight)\n        } else {\n          const lh = height + this._previousDescent\n\n          if (height > 0 && lh !== this._previousHeight) {\n            this._previousHeight = lh\n            chunk += ops.TL(lh)\n          }\n\n          if (left > this._cursor.x) {\n            // set new x and y position\n            chunk += ops.Tm(1, 0, 0, 1, left, this._cursor.y)\n          } else {\n            // move to next line\n            chunk += ops.Tstar()\n          }\n        }\n\n        if (height > 0) {\n          this._previousDescent = descent\n        }\n\n        const out = []\n\n        const rangeStyleArgs = [this._doc, left, this._cursor.y, height, spacing]\n        const underlineStyle = new UnderlineRangeStyle(...rangeStyleArgs)\n        const strikethroughStyle = new StrikethroughRangeStyle(...rangeStyleArgs)\n        const linkStyle = new LinkRangeStyle(...rangeStyleArgs)\n        const destinationStyle = new DestinationRangeStyle(...rangeStyleArgs)\n        const goToStyle = new GoToRangeStyle(...rangeStyleArgs)\n\n        const lastIx = this._line.length - 1\n        for (let i = 0; i < this._line.length; ++i) {\n          const w = this._line[i]\n\n          const fontStyleChanged = w.font !== this._previousFont || w.fontSize !== this._previousFontSize\n          const colorChanged = !util.rgbEqual(w.color, this._previousColor)\n\n          chunk += underlineStyle.applyStyle(w, i === lastIx, fontStyleChanged || colorChanged)\n          chunk += strikethroughStyle.applyStyle(w, i === lastIx, fontStyleChanged || colorChanged)\n          chunk += linkStyle.applyStyle(w, i === lastIx, fontStyleChanged || colorChanged)\n          chunk += destinationStyle.applyStyle(w, i === lastIx, fontStyleChanged || colorChanged)\n          chunk += goToStyle.applyStyle(w, i === lastIx, fontStyleChanged || colorChanged)\n\n          if (fontStyleChanged || colorChanged) {\n            if (out.length > 0) {\n              chunk += ops.TJ(out)\n            }\n\n            if (fontStyleChanged) {\n              this._previousFont = w.font\n              this._previousFontSize = w.fontSize\n\n              const alias = this._doc._fontAlias(w.font)\n\n              // set font and font size\n              chunk += ops.Tf(alias, w.fontSize)\n            }\n\n            // set color if it has changed\n            if (colorChanged) {\n              this._previousColor = w.color\n              chunk += ops.sc(...w.color)\n            }\n\n            out.length = 0\n          }\n\n          const kerning = w.wordWidth.kerning\n          if (kerning.length > 0) {\n            let pos = 0\n            for (let i = 0; i < kerning.length; ++i) {\n              let subword = w.word.substring(pos, kerning[i].pos)\n              out.push(w.font.encode(subword), kerning[i].offset)\n              pos = kerning[i].pos\n            }\n            out.push(w.font.encode(w.word.substring(pos)))\n          } else {\n            out.push(w.font.encode(w.word))\n          }\n\n          if (i < this._line.length - 1 && w.spaceWidth > 0) {\n            // if is not last and has spaceWidth set\n            out.push(calcSpaceWidth(spacing, w.font, w.fontSize))\n          }\n        }\n        if (out.length > 0) {\n          chunk += ops.TJ(out)\n        }\n\n        await this._doc._write(chunk)\n\n        this._cursor.y -= descent\n\n        // reset / update variables\n        this._spaceLeft = this._cursor.width\n        this._line.length = 0 // empty line array\n        this._isFirstLine = false\n        this._isNewLine = bk && bk.required\n\n        postponeLinebreak = bk && bk.required && word !== null && word.length > 0\n      }\n\n      // consider word for next line\n      if (word) {\n        this._line.push(\n          new TextChunk({\n            wordWidth, spaceWidth, word, font, fontSize,\n            color, decoration,\n            link, destination, goTo\n          })\n        )\n\n        this._spaceLeft -= offsetWidth\n      }\n\n      bk = null\n    }\n  }\n\n  /// public API\n\n  add(text, opts) {\n    this._begin(null) // trigger error, if text is already ended\n    this._parts++\n    this._pending.push(() => this._render(text, opts || {}))\n\n    return this\n  }\n\n  append(text, opts) {\n    this._begin(null) // trigger error, if text is already ended\n\n    this._parts++\n    this._pending.push(() => {\n      if (this._line.length > 0) {\n        const w = this._line[this._line.length - 1]\n        this._spaceLeft += w.spaceWidth\n        w.spaceWidth = 0 // set space width to zero\n      }\n      return this._render(text, opts || {})\n    })\n\n    return this\n  }\n\n  br() {\n    this._begin(null) // trigger error, if text is already ended\n\n    this._parts++\n    this._pending.push(() => this._render('\\n\\n', {}))\n\n    return this\n  }\n}\n\nfunction calcSpaceWidth(spacing, font, fontSize) {\n  const scaleFactor = 1000 / fontSize\n  return -(spacing + font.stringWidth(' ', fontSize)) * scaleFactor\n}\n\nclass TextChunk {\n  constructor(values) {\n    this.wordWidth = values.wordWidth\n    this.spaceWidth = values.spaceWidth\n    this.word = values.word\n    this.font = values.font\n    this.fontSize = values.fontSize\n    this.color = values.color\n    this.decoration = values.decoration\n    this.link = values.link\n    this.destination = values.destination\n    this.goTo = values.goTo\n  }\n}\n\nclass RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    this.doc = doc\n    this.from = x\n    this.width = 0\n    this.y = y\n    this.height = height\n    this.spacing = spacing\n    this.isActive = false\n    this.lastSpaceWidth = 0\n  }\n\n  applyStyle(textChunk, isLast, fontStyleChanged) {\n    const shouldApply = this._active(textChunk)\n    let chunk = ''\n\n    if (shouldApply && !fontStyleChanged && this.isActive) {\n      this.width += this.lastSpaceWidth\n    }\n\n    if (this.isActive && (!shouldApply || fontStyleChanged)) {\n      chunk += this._applyStyle(textChunk)\n      this.from += this.width + this.lastSpaceWidth\n      this.width = 0\n    }\n\n    if ((!this.isActive || shouldApply) || this.isActive && fontStyleChanged) {\n      this._start(textChunk)\n    }\n\n    this.isActive = shouldApply\n    this.lastSpaceWidth = this.spacing || textChunk.spaceWidth\n    if (this.isActive) {\n      this.width += textChunk.wordWidth\n    } else {\n      this.from += textChunk.wordWidth + this.lastSpaceWidth\n    }\n\n    if (this.isActive && isLast) {\n      chunk += this._applyStyle(textChunk)\n    }\n\n    return chunk\n  }\n\n  _active(textChunk) {\n    // abstract\n  }\n\n  _start(textChunk) {\n    // abstract\n  }\n\n  _applyStyle(textChunk) {\n    // abstract\n  }\n}\n\nclass UnderlineRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing)\n    this.underlinePosition = 0\n    this.underlineThickness = 0\n    this.color = null\n  }\n\n  _active(textChunk) {\n    return textChunk.decoration & UNDERLINE_FLAG\n  }\n\n  _start(textChunk) {\n    this.underlinePosition = textChunk.font.underlinePosition(textChunk.fontSize)\n    this.underlineThickness = textChunk.font.underlineThickness(textChunk.fontSize)\n    this.color = textChunk.color\n  }\n\n  _applyStyle(textChunk) {\n    const y = this.y + this.underlinePosition\n    return ops.w(this.underlineThickness)  // line width\n         + ops.SC(...this.color) // stroking color\n         + ops.S(this.from, y, 'm', this.from + this.width, y, 'l') // line\n  }\n}\n\nclass StrikethroughRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing)\n    this.ascent = 0\n    this.lineThickness = 0\n    this.color = null\n  }\n\n  _active(textChunk) {\n    return textChunk.decoration & STRIKETHROUGH_FLAG\n  }\n\n  _start(textChunk) {\n    this.ascent = textChunk.font.ascent(textChunk.fontSize)\n    this.lineThickness = textChunk.font.underlineThickness(textChunk.fontSize)\n    this.color = textChunk.color\n  }\n\n  _applyStyle(textChunk) {\n    const y = this.y + this.ascent * .35\n    return ops.w(this.lineThickness)  // line width\n         + ops.SC(...this.color) // stroking color\n         + ops.S(this.from, y, 'm', this.from + this.width, y, 'l') // line\n  }\n}\n\nclass LinkRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing)\n    this.link = null\n  }\n\n  applyStyle(textChunk, isLast, fontStyleChanged) {\n    if (this.link && textChunk.link !== this.link) {\n      fontStyleChanged = true\n    }\n    return RangeStyle.prototype.applyStyle.call(this, textChunk, isLast, fontStyleChanged)\n  }\n\n  _active(textChunk) {\n    return textChunk.link !== undefined\n  }\n\n  _start(textChunk) {\n    this.link = textChunk.link\n  }\n\n  _applyStyle(textChunk) {\n    this.doc._annotations.push(new PDF.Dictionary({\n      Type: 'Annot',\n      Subtype: 'Link',\n      Rect: new PDF.Array([this.from, this.y, this.from + this.width, this.y + this.height]),\n      Border: new PDF.Array([0, 0, 0]),\n      A: new PDF.Dictionary({\n        Type: 'Action',\n        S: 'URI',\n        URI: new PDF.String(this.link),\n      }),\n    }))\n    return ''\n  }\n}\n\nclass DestinationRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing)\n    this.destination = null\n  }\n\n  applyStyle(textChunk, isLast, fontStyleChanged) {\n    if (this.destination && textChunk.destination !== this.destination) {\n      fontStyleChanged = true\n    }\n    return RangeStyle.prototype.applyStyle.call(this, textChunk, isLast, fontStyleChanged)\n  }\n\n  _active(textChunk) {\n    return textChunk.destination !== undefined\n  }\n\n  _start(textChunk) {\n    this.destination = textChunk.destination\n  }\n\n  _applyStyle(textChunk) {\n    this.doc._destinations.set(this.destination, new PDF.Array([\n      this.doc._currentPage.toReference(),\n      new PDF.Name('XYZ'),\n      this.from,\n      this.y,\n      null,\n    ]))\n    return ''\n  }\n}\n\nclass GoToRangeStyle extends RangeStyle {\n  constructor(doc, x, y, height, spacing) {\n    super(doc, x, y, height, spacing)\n    this.goTo = null\n  }\n\n  applyStyle(textChunk, isLast, fontStyleChanged) {\n    if (this.goTo && textChunk.goTo !== this.goTo) {\n      fontStyleChanged = true\n    }\n    return RangeStyle.prototype.applyStyle.call(this, textChunk, isLast, fontStyleChanged)\n  }\n\n  _active(textChunk) {\n    return textChunk.goTo !== undefined\n  }\n\n  _start(textChunk) {\n    this.goTo = textChunk.goTo\n  }\n\n  _applyStyle(textChunk) {\n    this.doc._annotations.push(new PDF.Dictionary({\n      Type: 'Annot',\n      Subtype: 'Link',\n      Rect: new PDF.Array([this.from, this.y, this.from + this.width, this.y + this.height]),\n      Border: new PDF.Array([0, 0, 0]),\n      A: new PDF.Dictionary({\n        S: 'GoTo',\n        D: new PDF.String(this.goTo),\n      }),\n    }))\n    return ''\n  }\n}\n\nText.DestinationRangeStyle = DestinationRangeStyle\n"]},"metadata":{},"sourceType":"script"}