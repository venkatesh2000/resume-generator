{"ast":null,"code":"'use strict';\n\nclass PDFName {\n  constructor(name) {\n    if (!name) {\n      throw new Error('A Name cannot be undefined');\n    }\n\n    if (name instanceof PDFName) {\n      return name;\n    }\n\n    if (name[0] === '/') {\n      name = name.substr(1);\n    } // white-space characters are not allowed\n\n\n    if (name.match(/[\\x00]/)) {\n      throw new Error('A Name mustn\\'t contain the null characters');\n    }\n\n    name = name.toString(); // Beginning with PDF 1.2, any character except null (character code 0)\n    // may be included in a name by writing its 2-digit hexadecimal code,\n    // preceded by the number sign character (#)\n    // ... it is recommended but not required for characters whose codes\n    // are outside the range 33 (!) to 126 (~)\n\n    name = name.replace(/[^\\x21-\\x7e]/g, function (c) {\n      let code = c.charCodeAt(0); // replace unicode characters with `_`\n\n      if (code > 0xff) {\n        code = 0x5f;\n      }\n\n      return '#' + Number(code).toString(16);\n    }); // Add # in front of delimiter characters\n    //     25  %\n    //     28  (\n    //     29  )\n    //     2f  /\n    //     3c  <\n    //     3e  >\n    //     5b  [\n    //     5d  ]\n    //     7b  {\n    //     7d  }\n\n    name = name.replace(/[\\x25\\x28\\x29\\x2f\\x3c\\x3e\\x5b\\x5d\\x7b\\x7d]/g, function (c) {\n      let code = c.charCodeAt(0);\n      return '#' + Number(code).toString(16);\n    });\n    this.name = name;\n  }\n\n  toString() {\n    return '/' + this.name;\n  }\n\n  static parse(xref, lexer, trial) {\n    if (lexer.getString(1) !== '/') {\n      if (trial) {\n        return undefined;\n      }\n\n      throw new Error('Name must start with a leading slash, found: ' + lexer.getString(1));\n    }\n\n    lexer.shift(1);\n    let name = '';\n    let done = false;\n    let c;\n\n    while (!done && (c = lexer._nextCharCode()) >= 0) {\n      switch (true) {\n        case c === 0x28: // (\n\n        case c === 0x29: // )\n\n        case c === 0x3c: // <\n\n        case c === 0x3e: // >\n\n        case c === 0x5b: // [\n\n        case c === 0x5d: // ]\n\n        case c === 0x7b: // {\n\n        case c === 0x7d: // }\n\n        case c === 0x2f: // /\n\n        case c === 0x25:\n          // %\n          done = true;\n          break;\n\n        case c === 0x23:\n          // #\n          const hex = lexer.readString(2);\n          name += String.fromCharCode(parseInt(hex, 16));\n          break;\n\n        case c >= 0x22 && c <= 0x7e:\n          // inside range of 33 (!) to 126 (~)\n          name += String.fromCharCode(c);\n          break;\n\n        default:\n          done = true;\n          break;\n      }\n    }\n\n    lexer.shift(-1);\n    return new PDFName(name);\n  }\n\n}\n\nmodule.exports = PDFName;","map":{"version":3,"sources":["/mnt/c/Users/Venkatesh/Documents/6th Sem/Web Dev/project/resume-generator/node_modules/pdfjs/lib/object/name.js"],"names":["PDFName","constructor","name","Error","substr","match","toString","replace","c","code","charCodeAt","Number","parse","xref","lexer","trial","getString","undefined","shift","done","_nextCharCode","hex","readString","String","fromCharCode","parseInt","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nclass PDFName {\n  constructor(name) {\n    if (!name) {\n      throw new Error('A Name cannot be undefined')\n    }\n\n    if (name instanceof PDFName) {\n      return name\n    }\n\n    if (name[0] === '/') {\n      name = name.substr(1)\n    }\n\n    // white-space characters are not allowed\n    if (name.match(/[\\x00]/)) {\n      throw new Error('A Name mustn\\'t contain the null characters')\n    }\n\n    name = name.toString()\n\n    // Beginning with PDF 1.2, any character except null (character code 0)\n    // may be included in a name by writing its 2-digit hexadecimal code,\n    // preceded by the number sign character (#)\n    // ... it is recommended but not required for characters whose codes\n    // are outside the range 33 (!) to 126 (~)\n    name = name.replace(/[^\\x21-\\x7e]/g, function(c) {\n      let code = c.charCodeAt(0)\n      // replace unicode characters with `_`\n      if (code > 0xff) {\n        code = 0x5f\n      }\n      return '#' + Number(code).toString(16)\n    })\n\n    // Add # in front of delimiter characters\n    //     25  %\n    //     28  (\n    //     29  )\n    //     2f  /\n    //     3c  <\n    //     3e  >\n    //     5b  [\n    //     5d  ]\n    //     7b  {\n    //     7d  }\n    name = name.replace(/[\\x25\\x28\\x29\\x2f\\x3c\\x3e\\x5b\\x5d\\x7b\\x7d]/g, function(c) {\n      let code = c.charCodeAt(0)\n      return '#' + Number(code).toString(16)\n    })\n\n    this.name = name\n  }\n\n  toString() {\n    return '/' + this.name\n  }\n\n  static parse(xref, lexer, trial) {\n    if (lexer.getString(1) !== '/') {\n      if (trial) {\n        return undefined\n      }\n\n      throw new Error('Name must start with a leading slash, found: ' + lexer.getString(1))\n    }\n\n    lexer.shift(1)\n\n    let name = ''\n\n    let done = false\n    let c\n    while (!done && (c = lexer._nextCharCode()) >= 0) {\n      switch (true) {\n        case c === 0x28: // (\n        case c === 0x29: // )\n        case c === 0x3c: // <\n        case c === 0x3e: // >\n        case c === 0x5b: // [\n        case c === 0x5d: // ]\n        case c === 0x7b: // {\n        case c === 0x7d: // }\n        case c === 0x2f: // /\n        case c === 0x25: // %\n          done = true\n          break\n        case c === 0x23: // #\n          const hex = lexer.readString(2)\n          name += String.fromCharCode(parseInt(hex, 16))\n          break\n        case c >= 0x22 && c <= 0x7e: // inside range of 33 (!) to 126 (~)\n          name += String.fromCharCode(c)\n          break\n        default:\n          done = true\n          break\n      }\n    }\n\n    lexer.shift(-1)\n\n    return new PDFName(name)\n  }\n}\n\nmodule.exports = PDFName\n"]},"metadata":{},"sourceType":"script"}